{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\n\nexport class LFO extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n\n    this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n\n    this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n\n    this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n\n    this._fromType = Param.prototype._fromType; // @ts-ignore\n\n    this._toType = Param.prototype._toType; // @ts-ignore\n\n    this._is = Param.prototype._is; // @ts-ignore\n\n    this._clampValue = Param.prototype._clampValue;\n    const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n    this._oscillator = new Oscillator(options);\n    this.frequency = this._oscillator.frequency;\n    this._amplitudeGain = new Gain({\n      context: this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    this.amplitude = this._amplitudeGain.gain;\n    this._stoppedSignal = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    this._zeros = new Zero({\n      context: this.context\n    });\n    this._a2g = new AudioToGain({\n      context: this.context\n    });\n    this._scaler = this.output = new Scale({\n      context: this.context,\n      max: options.max,\n      min: options.min\n    });\n    this.units = options.units;\n    this.min = options.min;\n    this.max = options.max; // connect it up\n\n    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\n    this._zeros.connect(this._a2g);\n\n    this._stoppedSignal.connect(this._a2g);\n\n    readOnly(this, [\"amplitude\", \"frequency\"]);\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      amplitude: 1,\n      frequency: \"4n\",\n      max: 1,\n      min: 0,\n      type: \"sine\",\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the LFO.\n   * @param time The time the LFO will start\n   */\n\n\n  start(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(0, time);\n\n    this._oscillator.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the LFO.\n   * @param  time The time the LFO will stop\n   */\n\n\n  stop(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\n    this._oscillator.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the start/stop/pause to the transport\n   * and the frequency to the bpm of the transport\n   * @example\n   * const lfo = new Tone.LFO(\"8n\");\n   * lfo.sync().start(0);\n   * // the rate of the LFO will always be an eighth note, even as the tempo changes\n   */\n\n\n  sync() {\n    this._oscillator.sync();\n\n    this._oscillator.syncFrequency();\n\n    return this;\n  }\n  /**\n   * unsync the LFO from transport control\n   */\n\n\n  unsync() {\n    this._oscillator.unsync();\n\n    this._oscillator.unsyncFrequency();\n\n    return this;\n  }\n  /**\n   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n   */\n\n\n  _setStoppedValue() {\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The minimum output of the LFO.\n   */\n\n\n  get min() {\n    return this._toType(this._scaler.min);\n  }\n\n  set min(min) {\n    min = this._fromType(min);\n    this._scaler.min = min;\n  }\n  /**\n   * The maximum output of the LFO.\n   */\n\n\n  get max() {\n    return this._toType(this._scaler.max);\n  }\n\n  set max(max) {\n    max = this._fromType(max);\n    this._scaler.max = max;\n  }\n  /**\n   * The type of the oscillator: See [[Oscillator.type]]\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The oscillator's partials array: See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    this._oscillator.partials = partials;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The phase of the LFO.\n   */\n\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The output units of the LFO.\n   */\n\n\n  get units() {\n    return this._units;\n  }\n\n  set units(val) {\n    const currentMin = this.min;\n    const currentMax = this.max; // convert the min and the max\n\n    this._units = val;\n    this.min = currentMin;\n    this.max = currentMax;\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   */\n\n\n  get state() {\n    return this._oscillator.state;\n  }\n  /**\n   * @param node the destination to connect to\n   * @param outputNum the optional output number\n   * @param inputNum the input number\n   */\n\n\n  connect(node, outputNum, inputNum) {\n    if (node instanceof Param || node instanceof Signal) {\n      this.convert = node.convert;\n      this.units = node.units;\n    }\n\n    connectSignal(this, node, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._oscillator.dispose();\n\n    this._stoppedSignal.dispose();\n\n    this._zeros.dispose();\n\n    this._scaler.dispose();\n\n    this._a2g.dispose();\n\n    this._amplitudeGain.dispose();\n\n    this.amplitude.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Gain","Param","ToneAudioNode","optionsFromArguments","readOnly","AudioToGain","Scale","connectSignal","Signal","Zero","Oscillator","LFO","constructor","getDefaults","arguments","prototype","_fromType","_toType","_is","_clampValue","options","_oscillator","frequency","_amplitudeGain","context","gain","amplitude","units","_stoppedSignal","value","_zeros","_a2g","_scaler","output","max","min","chain","connect","phase","Object","assign","type","start","time","toSeconds","setValueAtTime","stop","_stoppedValue","sync","syncFrequency","unsync","unsyncFrequency","_setStoppedValue","getInitialValue","partials","_units","val","currentMin","currentMax","state","node","outputNum","inputNum","convert","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/LFO.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorOptions } from \"./OscillatorInterface\";\n\nexport type LFOOptions = {\n\tmin: number;\n\tmax: number;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n} & ToneOscillatorOptions;\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\tthis._oscillator = new Oscillator(options as ToneOscillatorConstructorOptions);\n\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\ttype: \"sine\",\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n\t */\n\tprivate _setStoppedValue() {\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The oscillator's partials array: See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tthis._oscillator.partials = partials;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}