{"ast":null,"code":"import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect } from \"./Effect\";\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\n\nexport class Distortion extends Effect {\n  constructor() {\n    super(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n    this.name = \"Distortion\";\n    const options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n    this._shaper = new WaveShaper({\n      context: this.context,\n      length: 4096\n    });\n    this._distortion = options.distortion;\n    this.connectEffect(this._shaper);\n    this.distortion = options.distortion;\n    this.oversample = options.oversample;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      distortion: 0.4,\n      oversample: \"none\"\n    });\n  }\n  /**\n   * The amount of distortion. Nominal range is between 0 and 1.\n   */\n\n\n  get distortion() {\n    return this._distortion;\n  }\n\n  set distortion(amount) {\n    this._distortion = amount;\n    const k = amount * 100;\n    const deg = Math.PI / 180;\n\n    this._shaper.setMap(x => {\n      if (Math.abs(x) < 0.001) {\n        // should output 0 when input is 0\n        return 0;\n      } else {\n        return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n      }\n    });\n  }\n  /**\n   * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    this._shaper.oversample = oversampling;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,oBAAT,QAAqC,uBAArC;AACA,SAASC,UAAT,QAA2B,sBAA3B;AACA,SAASC,MAAT,QAAsC,UAAtC;AAOA;;;;;;;;;;;AAUA,OAAM,MAAOC,UAAP,SAA0BD,MAA1B,CAAmD;EAmBxDE;IAEC,MAAMJ,oBAAoB,CAACG,UAAU,CAACE,WAAX,EAAD,EAA2BC,SAA3B,EAAsC,CAAC,YAAD,CAAtC,CAA1B;IAnBQ,YAAe,YAAf;IAoBR,MAAMC,OAAO,GAAGP,oBAAoB,CAACG,UAAU,CAACE,WAAX,EAAD,EAA2BC,SAA3B,EAAsC,CAAC,YAAD,CAAtC,CAApC;IAEA,KAAKE,OAAL,GAAe,IAAIP,UAAJ,CAAe;MAC7BQ,OAAO,EAAE,KAAKA,OADe;MAE7BC,MAAM,EAAE;IAFqB,CAAf,CAAf;IAKA,KAAKC,WAAL,GAAmBJ,OAAO,CAACK,UAA3B;IAEA,KAAKC,aAAL,CAAmB,KAAKL,OAAxB;IACA,KAAKI,UAAL,GAAkBL,OAAO,CAACK,UAA1B;IACA,KAAKE,UAAL,GAAkBP,OAAO,CAACO,UAA1B;EACA;;EAEiB,OAAXT,WAAW;IACjB,OAAOU,MAAM,CAACC,MAAP,CAAcd,MAAM,CAACG,WAAP,EAAd,EAAoC;MAC1CO,UAAU,EAAE,GAD8B;MAE1CE,UAAU,EAAE;IAF8B,CAApC,CAAP;EAIA;EAED;;;;;EAGc,IAAVF,UAAU;IACb,OAAO,KAAKD,WAAZ;EACA;;EACa,IAAVC,UAAU,CAACK,MAAD,EAAO;IACpB,KAAKN,WAAL,GAAmBM,MAAnB;IACA,MAAMC,CAAC,GAAGD,MAAM,GAAG,GAAnB;IACA,MAAME,GAAG,GAAGC,IAAI,CAACC,EAAL,GAAU,GAAtB;;IACA,KAAKb,OAAL,CAAac,MAAb,CAAqBC,CAAD,IAAM;MACzB,IAAIH,IAAI,CAACI,GAAL,CAASD,CAAT,IAAc,KAAlB,EAAyB;QACxB;QACA,OAAO,CAAP;MACA,CAHD,MAGO;QACN,OAAO,CAAC,IAAIL,CAAL,IAAUK,CAAV,GAAc,EAAd,GAAmBJ,GAAnB,IAA0BC,IAAI,CAACC,EAAL,GAAUH,CAAC,GAAGE,IAAI,CAACI,GAAL,CAASD,CAAT,CAAxC,CAAP;MACA;IACD,CAPD;EAQA;EAED;;;;;EAGc,IAAVT,UAAU;IACb,OAAO,KAAKN,OAAL,CAAaM,UAApB;EACA;;EACa,IAAVA,UAAU,CAACW,YAAD,EAAa;IAC1B,KAAKjB,OAAL,CAAaM,UAAb,GAA0BW,YAA1B;EACA;;EAEDC,OAAO;IACN,MAAMA,OAAN;;IACA,KAAKlB,OAAL,CAAakB,OAAb;;IACA,OAAO,IAAP;EACA;;AA7EuD","names":["optionsFromArguments","WaveShaper","Effect","Distortion","constructor","getDefaults","arguments","options","_shaper","context","length","_distortion","distortion","connectEffect","oversample","Object","assign","amount","k","deg","Math","PI","setMap","x","abs","oversampling","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/effect/Distortion.ts"],"sourcesContent":["import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n\t\tconst options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}