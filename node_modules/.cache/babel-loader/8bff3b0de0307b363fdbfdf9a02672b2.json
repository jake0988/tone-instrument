{"ast":null,"code":"import { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\n\nexport class StateTimeline extends Timeline {\n  constructor() {\n    let initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"stopped\";\n    super();\n    this.name = \"StateTimeline\";\n    this._initial = initial;\n    this.setStateAtTime(this._initial, 0);\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n\n\n  getValueAtTime(time) {\n    const event = this.get(time);\n\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  }\n  /**\n   * Add a state to the timeline.\n   * @param  state The name of the state to set.\n   * @param  time  The time to query.\n   * @param options Any additional options that are needed in the timeline.\n   */\n\n\n  setStateAtTime(state, time, options) {\n    assertRange(time, 0);\n    this.add(Object.assign({}, options, {\n      state,\n      time\n    }));\n    return this;\n  }\n  /**\n   * Return the event before the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check before\n   * @return  The event with the given state before the time\n   */\n\n\n  getLastState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    for (let i = index; i >= 0; i--) {\n      const event = this._timeline[i];\n\n      if (event.state === state) {\n        return event;\n      }\n    }\n  }\n  /**\n   * Return the event after the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check from\n   * @return  The event with the given state after the time\n   */\n\n\n  getNextState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    if (index !== -1) {\n      for (let i = index; i < this._timeline.length; i++) {\n        const event = this._timeline[i];\n\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,QAAT,QAAwC,YAAxC;AACA,SAASC,WAAT,QAA4B,SAA5B;AASA;;;;;AAIA,OAAM,MAAOC,aAAP,SAAgEF,QAAhE,CAAgH;EASrHG,cAA8C;IAAA,IAAlCC,OAAkC,uEAAT,SAAS;IAC7C;IARQ,YAAe,eAAf;IASR,KAAKC,QAAL,GAAgBD,OAAhB;IACA,KAAKE,cAAL,CAAoB,KAAKD,QAAzB,EAAmC,CAAnC;EACA;EAED;;;;;;;;EAMAE,cAAc,CAACC,IAAD,EAAc;IAC3B,MAAMC,KAAK,GAAG,KAAKC,GAAL,CAASF,IAAT,CAAd;;IACA,IAAIC,KAAK,KAAK,IAAd,EAAoB;MACnB,OAAOA,KAAK,CAACE,KAAb;IACA,CAFD,MAEO;MACN,OAAO,KAAKN,QAAZ;IACA;EACD;EAED;;;;;;;;EAMAC,cAAc,CAACK,KAAD,EAAuBH,IAAvB,EAAsCI,OAAtC,EAAiE;IAC9EX,WAAW,CAACO,IAAD,EAAO,CAAP,CAAX;IACA,KAAKK,GAAL,CAASC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,EAA2B;MACnCD,KADmC;MAEnCH;IAFmC,CAA3B,CAAT;IAIA,OAAO,IAAP;EACA;EAED;;;;;;;;EAMAQ,YAAY,CAACL,KAAD,EAAuBH,IAAvB,EAAmC;IAC9C;IACA,MAAMS,KAAK,GAAG,KAAKC,OAAL,CAAaV,IAAb,CAAd;;IACA,KAAK,IAAIW,CAAC,GAAGF,KAAb,EAAoBE,CAAC,IAAI,CAAzB,EAA4BA,CAAC,EAA7B,EAAiC;MAChC,MAAMV,KAAK,GAAG,KAAKW,SAAL,CAAeD,CAAf,CAAd;;MACA,IAAIV,KAAK,CAACE,KAAN,KAAgBA,KAApB,EAA2B;QAC1B,OAAOF,KAAP;MACA;IACD;EACD;EAED;;;;;;;;EAMAY,YAAY,CAACV,KAAD,EAAuBH,IAAvB,EAAmC;IAC9C;IACA,MAAMS,KAAK,GAAG,KAAKC,OAAL,CAAaV,IAAb,CAAd;;IACA,IAAIS,KAAK,KAAK,CAAC,CAAf,EAAkB;MACjB,KAAK,IAAIE,CAAC,GAAGF,KAAb,EAAoBE,CAAC,GAAG,KAAKC,SAAL,CAAeE,MAAvC,EAA+CH,CAAC,EAAhD,EAAoD;QACnD,MAAMV,KAAK,GAAG,KAAKW,SAAL,CAAeD,CAAf,CAAd;;QACA,IAAIV,KAAK,CAACE,KAAN,KAAgBA,KAApB,EAA2B;UAC1B,OAAOF,KAAP;QACA;MACD;IACD;EACD;;AA/EoH","names":["Timeline","assertRange","StateTimeline","constructor","initial","_initial","setStateAtTime","getValueAtTime","time","event","get","state","options","add","Object","assign","getLastState","index","_search","i","_timeline","getNextState","length"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/util/StateTimeline.ts"],"sourcesContent":["import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t\tthis.setStateAtTime(this._initial, 0);\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tassertRange(time, 0);\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}