{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\"); // set the initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    this.setTicksAtTime(0, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n\n\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time); // cancel the previous stop\n\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n\n        this._state.cancel(event.time);\n      }\n    }\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n\n\n  cancel(time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedTicks = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n\n\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n\n\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedSeconds = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n\n    const offset = this._tickOffset.get(before);\n\n    const event = this._state.get(before);\n\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n\n\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    });\n\n    let error = null;\n\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._state.dispose();\n\n    this._tickOffset.dispose();\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","constructor","getDefaults","arguments","options","frequency","context","units","value","_state","setStateAtTime","setTicksAtTime","Object","assign","state","getStateAtTime","now","start","time","offset","computedTime","toSeconds","getValueAtTime","stop","event","get","_tickOffset","cancel","pause","getTicksAtTime","stopEvent","getLastState","tmpEvent","add","lastState","elapsedTicks","forEachBetween","sampleTime","e","periodStartTime","offsetEvent","ticks","remove","t","seconds","getSecondsAtTime","s","timeToTicks","elapsedSeconds","getDurationOfTicks","getTimeOfTick","tick","before","startTime","Math","max","absoluteTicks","forEachTickBetween","endTime","callback","lastStateEvent","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/TickSource.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}