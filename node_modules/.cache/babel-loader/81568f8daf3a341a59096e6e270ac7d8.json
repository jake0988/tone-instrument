{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport class ToneAudioBuffer extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    this.onload = noOp;\n    const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    this.reverse = options.reverse;\n    this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      this.load(options.url).catch(options.onerror);\n    }\n  }\n\n  static getDefaults() {\n    return {\n      onerror: noOp,\n      onload: noOp,\n      reverse: false\n    };\n  }\n  /**\n   * The sample rate of the AudioBuffer\n   */\n\n\n  get sampleRate() {\n    if (this._buffer) {\n      return this._buffer.sampleRate;\n    } else {\n      return getContext().sampleRate;\n    }\n  }\n  /**\n   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n   */\n\n\n  set(buffer) {\n    if (buffer instanceof ToneAudioBuffer) {\n      // if it's loaded, set it\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        // otherwise when it's loaded, invoke it's callback\n        buffer.onload = () => {\n          this.set(buffer);\n          this.onload(this);\n        };\n      }\n    } else {\n      this._buffer = buffer;\n    } // reverse it initially\n\n\n    if (this._reversed) {\n      this._reverse();\n    }\n\n    return this;\n  }\n  /**\n   * The audio buffer stored in the object.\n   */\n\n\n  get() {\n    return this._buffer;\n  }\n  /**\n   * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n   * Invokes the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   * @returns A Promise which resolves with this ToneAudioBuffer\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n        this.set(audioBuffer); // invoke the onload method\n\n        this.onload(this);\n      });\n      ToneAudioBuffer.downloads.push(doneLoading);\n\n      try {\n        yield doneLoading;\n      } finally {\n        // remove the downloaded file\n        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n        ToneAudioBuffer.downloads.splice(index, 1);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._buffer = undefined;\n    return this;\n  }\n  /**\n   * Set the audio buffer from the array.\n   * To create a multichannel AudioBuffer, pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   */\n\n\n  fromArray(array) {\n    const isMultidimensional = isArray(array) && array[0].length > 0;\n    const channels = isMultidimensional ? array.length : 1;\n    const len = isMultidimensional ? array[0].length : array.length;\n    const context = getContext();\n    const buffer = context.createBuffer(channels, len, context.sampleRate);\n    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n    for (let c = 0; c < channels; c++) {\n      buffer.copyToChannel(multiChannelArray[c], c);\n    }\n\n    this._buffer = buffer;\n    return this;\n  }\n  /**\n   * Sums multiple channels into 1 channel\n   * @param chanNum Optionally only copy a single channel from the array.\n   */\n\n\n  toMono(chanNum) {\n    if (isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      let outputArray = new Float32Array(this.length);\n      const numChannels = this.numberOfChannels;\n\n      for (let channel = 0; channel < numChannels; channel++) {\n        const channelArray = this.toArray(channel);\n\n        for (let i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      } // divide by the number of channels\n\n\n      outputArray = outputArray.map(sample => sample / numChannels);\n      this.fromArray(outputArray);\n    }\n\n    return this;\n  }\n  /**\n   * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n   * Float32Array, and multichannel buffers will return multidimensional arrays.\n   * @param channel Optionally only copy a single channel from the array.\n   */\n\n\n  toArray(channel) {\n    if (isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      const ret = [];\n\n      for (let c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n\n      return ret;\n    }\n  }\n  /**\n   * Returns the Float32Array representing the PCM audio data for the specific channel.\n   * @param  channel  The channel number to return\n   * @return The audio as a TypedArray\n   */\n\n\n  getChannelData(channel) {\n    if (this._buffer) {\n      return this._buffer.getChannelData(channel);\n    } else {\n      return new Float32Array(0);\n    }\n  }\n  /**\n   * Cut a subsection of the array and return a buffer of the\n   * subsection. Does not modify the original buffer\n   * @param start The time to start the slice\n   * @param end The end time to slice. If none is given will default to the end of the buffer\n   */\n\n\n  slice(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n    const startSamples = Math.floor(start * this.sampleRate);\n    const endSamples = Math.floor(end * this.sampleRate);\n    assert(startSamples < endSamples, \"The start time must be less than the end time\");\n    const length = endSamples - startSamples;\n    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n    for (let channel = 0; channel < this.numberOfChannels; channel++) {\n      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n    }\n\n    return new ToneAudioBuffer(retBuffer);\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  _reverse() {\n    if (this.loaded) {\n      for (let i = 0; i < this.numberOfChannels; i++) {\n        this.getChannelData(i).reverse();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * If the buffer is loaded or not\n   */\n\n\n  get loaded() {\n    return this.length > 0;\n  }\n  /**\n   * The duration of the buffer in seconds.\n   */\n\n\n  get duration() {\n    if (this._buffer) {\n      return this._buffer.duration;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The length of the buffer in samples\n   */\n\n\n  get length() {\n    if (this._buffer) {\n      return this._buffer.length;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n   */\n\n\n  get numberOfChannels() {\n    if (this._buffer) {\n      return this._buffer.numberOfChannels;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  get reverse() {\n    return this._reversed;\n  }\n\n  set reverse(rev) {\n    if (this._reversed !== rev) {\n      this._reversed = rev;\n\n      this._reverse();\n    }\n  }\n  /**\n   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n   * pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   * @return A ToneAudioBuffer created from the array\n   */\n\n\n  static fromArray(array) {\n    return new ToneAudioBuffer().fromArray(array);\n  }\n  /**\n   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n   * @param  url The url to load.\n   * @return A promise which resolves to a ToneAudioBuffer\n   */\n\n\n  static fromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buffer = new ToneAudioBuffer();\n      return yield buffer.load(url);\n    });\n  }\n  /**\n   * Loads a url using fetch and returns the AudioBuffer.\n   */\n\n\n  static load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // test if the url contains multiple extensions\n      const matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\n      if (matches) {\n        const extensions = matches[1].split(\"|\");\n        let extension = extensions[0];\n\n        for (const ext of extensions) {\n          if (ToneAudioBuffer.supportsType(ext)) {\n            extension = ext;\n            break;\n          }\n        }\n\n        url = url.replace(matches[0], extension);\n      } // make sure there is a slash between the baseUrl and the url\n\n\n      const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n      const response = yield fetch(baseUrl + url);\n\n      if (!response.ok) {\n        throw new Error(`could not load url: ${url}`);\n      }\n\n      const arrayBuffer = yield response.arrayBuffer();\n      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n      return audioBuffer;\n    });\n  }\n  /**\n   * Checks a url's extension to see if the current browser can play that file type.\n   * @param url The url/extension to test\n   * @return If the file extension can be played\n   * @static\n   * @example\n   * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n   * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n   */\n\n\n  static supportsType(url) {\n    const extensions = url.split(\".\");\n    const extension = extensions[extensions.length - 1];\n    const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  }\n  /**\n   * Returns a Promise which resolves when all of the buffers have loaded\n   */\n\n\n  static loaded() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this makes sure that the function is always async\n      yield Promise.resolve();\n\n      while (ToneAudioBuffer.downloads.length) {\n        yield ToneAudioBuffer.downloads[0];\n      }\n    });\n  }\n\n} //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","map":{"version":3,"mappings":"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","names":["getContext","Tone","isAudioBuffer","optionsFromArguments","noOp","isArray","isNumber","isString","assert","ToneAudioBuffer","constructor","options","getDefaults","arguments","reverse","onload","url","set","load","catch","onerror","sampleRate","_buffer","buffer","loaded","get","_reversed","_reverse","doneLoading","then","audioBuffer","downloads","push","index","indexOf","splice","dispose","undefined","fromArray","array","isMultidimensional","length","channels","len","context","createBuffer","multiChannelArray","c","copyToChannel","toMono","chanNum","toArray","outputArray","Float32Array","numChannels","numberOfChannels","channel","channelArray","i","map","sample","getChannelData","ret","slice","start","end","duration","startSamples","Math","floor","endSamples","retBuffer","subarray","rev","fromUrl","matches","match","extensions","split","extension","ext","supportsType","replace","baseUrl","endsWith","response","fetch","ok","Error","arrayBuffer","decodeAudioData","document","createElement","canPlayType","Promise","resolve"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/context/ToneAudioBuffer.ts"],"sourcesContent":["import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(audioBuffer => {\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t});\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}