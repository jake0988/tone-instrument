{"ast":null,"code":"import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\n\nfunction* upPatternGen(values) {\n  let index = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index++;\n  }\n}\n/**\n * Start at the last value and go down to 0\n */\n\n\nfunction* downPatternGen(values) {\n  let index = values.length - 1;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index--;\n  }\n}\n/**\n * Infinitely yield the generator\n */\n\n\nfunction* infiniteGen(values, gen) {\n  while (true) {\n    yield* gen(values);\n  }\n}\n/**\n * Make sure that the index is in the given range\n */\n\n\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\n\n\nfunction* alternatingGenerator(values, directionUp) {\n  let index = directionUp ? 0 : values.length - 1;\n\n  while (true) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n\n    if (directionUp) {\n      index++;\n\n      if (index >= values.length - 1) {\n        directionUp = false;\n      }\n    } else {\n      index--;\n\n      if (index <= 0) {\n        directionUp = true;\n      }\n    }\n  }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\n\n\nfunction* jumpUp(values) {\n  let index = 0;\n  let stepIndex = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? 2 : -1;\n  }\n}\n/**\n * Starting from the top move down 2, up 1\n */\n\n\nfunction* jumpDown(values) {\n  let index = values.length - 1;\n  let stepIndex = 0;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? -2 : 1;\n  }\n}\n/**\n * Choose a random index each time\n */\n\n\nfunction* randomGen(values) {\n  while (true) {\n    const randomIndex = Math.floor(Math.random() * values.length);\n    yield values[randomIndex];\n  }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\n\n\nfunction* randomOnce(values) {\n  // create an array of indices\n  const copy = [];\n\n  for (let i = 0; i < values.length; i++) {\n    copy.push(i);\n  }\n\n  while (copy.length > 0) {\n    // random choose an index, and then remove it so it's not chosen again\n    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n    const index = clampToArraySize(randVal[0], values);\n    yield values[index];\n  }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\n\n\nfunction* randomWalk(values) {\n  // randomly choose a starting index in the values array\n  let index = Math.floor(Math.random() * values.length);\n\n  while (true) {\n    if (index === 0) {\n      index++; // at bottom of array, so force upward step\n    } else if (index === values.length - 1) {\n      index--; // at top of array, so force downward step\n    } else if (Math.random() < 0.5) {\n      // else choose random downward or upward step\n      index--;\n    } else {\n      index++;\n    }\n\n    yield values[index];\n  }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\n\n\nexport function* PatternGenerator(values) {\n  let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"up\";\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // safeguards\n  assert(values.length > 0, \"The array must have more than one value in it\");\n\n  switch (pattern) {\n    case \"up\":\n      yield* infiniteGen(values, upPatternGen);\n\n    case \"down\":\n      yield* infiniteGen(values, downPatternGen);\n\n    case \"upDown\":\n      yield* alternatingGenerator(values, true);\n\n    case \"downUp\":\n      yield* alternatingGenerator(values, false);\n\n    case \"alternateUp\":\n      yield* infiniteGen(values, jumpUp);\n\n    case \"alternateDown\":\n      yield* infiniteGen(values, jumpDown);\n\n    case \"random\":\n      yield* randomGen(values);\n\n    case \"randomOnce\":\n      yield* infiniteGen(values, randomOnce);\n\n    case \"randomWalk\":\n      yield* randomWalk(values);\n  }\n}","map":{"version":3,"mappings":"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","names":["assert","clamp","upPatternGen","values","index","length","clampToArraySize","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomGen","randomIndex","Math","floor","random","randomOnce","copy","i","push","randVal","splice","randomWalk","PatternGenerator","pattern"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/event/PatternGenerator.ts"],"sourcesContent":["import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\" | \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index: number, values: any[]): number {\n\treturn clamp(index, 0, values.length - 1);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clampToArraySize(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk<T>(values: T[]): IterableIterator<T> {\n\t// randomly choose a starting index in the values array\n\tlet index = Math.floor(Math.random() * values.length);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom of array, so force upward step\n\t\t} else if (index === values.length - 1) {\n\t\t\tindex--; // at top of array, so force downward step\n\t\t} else if (Math.random() < 0.5) { // else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(values);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}