{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\n\nexport class Sampler extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    this._activeSources = new Map();\n    const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    const urlMap = {};\n    Object.keys(options.urls).forEach(note => {\n      const noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        const mid = new FrequencyClass(this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    this.attack = options.attack;\n    this.release = options.release;\n    this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      onerror: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  }\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n\n\n  _findClosest(midi) {\n    // searches within 8 octaves of the given midi note\n    const MAX_INTERVAL = 96;\n    let interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    throw new Error(`No available buffers for note: ${midi}`);\n  }\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n\n\n  triggerAttack(notes, time) {\n    let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    this.log(\"triggerAttack\", notes, time, velocity);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n      const midi = Math.round(midiFloat);\n      const remainder = midiFloat - midi; // find the closest note pitch\n\n      const difference = this._findClosest(midi);\n\n      const closestNote = midi - difference;\n\n      const buffer = this._buffers.get(closestNote);\n\n      const playbackRate = intervalToFrequencyRatio(difference + remainder); // play that note\n\n      const source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        curve: this.curve,\n        fadeIn: this.attack,\n        fadeOut: this.release,\n        playbackRate\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n      if (!isArray(this._activeSources.get(midi))) {\n        this._activeSources.set(midi, []);\n      }\n\n      this._activeSources.get(midi).push(source); // remove it when it's done\n\n\n      source.onended = () => {\n        if (this._activeSources && this._activeSources.has(midi)) {\n          const sources = this._activeSources.get(midi);\n\n          const index = sources.indexOf(source);\n\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n\n\n  triggerRelease(notes, time) {\n    this.log(\"triggerRelease\", notes, time);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the note\n\n      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n        const sources = this._activeSources.get(midi);\n\n        time = this.toSeconds(time);\n        sources.forEach(source => {\n          source.stop(time);\n        });\n\n        this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  }\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(sources => {\n      while (sources.length) {\n        const source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n\n    return this;\n  }\n\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n\n    return this;\n  }\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n\n\n  triggerAttackRelease(notes, duration, time) {\n    let velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach((note, index) => {\n        const d = duration[Math.min(index, duration.length - 1)];\n        this.triggerRelease(note, computedTime + this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n\n    return this;\n  }\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n\n\n  add(note, url, callback) {\n    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      const mid = new FrequencyClass(this.context, note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n\n    return this;\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.dispose();\n\n    this._activeSources.forEach(sources => {\n      sources.forEach(source => source.dispose());\n    });\n\n    this._activeSources.clear();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","map":{"version":3,"mappings":"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","names":["ToneAudioBuffers","ftomf","intervalToFrequencyRatio","FrequencyClass","optionsFromArguments","noOp","isArray","isNote","isNumber","Instrument","ToneBufferSource","timeRange","assert","Sampler","constructor","getDefaults","arguments","Map","options","urlMap","Object","keys","urls","forEach","note","noteNumber","parseInt","isFinite","mid","context","toMidi","_buffers","onload","baseUrl","onerror","attack","release","curve","loaded","Promise","resolve","then","assign","_findClosest","midi","MAX_INTERVAL","interval","has","Error","triggerAttack","notes","time","velocity","log","Array","midiFloat","toFrequency","Math","round","remainder","difference","closestNote","buffer","get","playbackRate","source","url","fadeIn","fadeOut","connect","output","start","duration","_activeSources","set","push","onended","sources","index","indexOf","splice","triggerRelease","length","toSeconds","stop","releaseAll","computedTime","shift","sync","_syncState","_syncMethod","triggerAttackRelease","d","min","add","callback","dispose","clear","__decorate"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/instrument/Sampler.ts"],"sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference + remainder);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}