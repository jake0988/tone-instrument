{"ast":null,"code":"import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class Synth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(Synth.getDefaults(), arguments));\n    this.name = \"Synth\";\n    const options = optionsFromArguments(Synth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign({\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }, options.oscillator));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: this.context\n    }, options.envelope)); // connect the oscillators to the output\n\n    this.oscillator.chain(this.envelope, this.output);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.3\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"triangle\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // the envelopes\n    this.envelope.triggerAttack(time, velocity);\n    this.oscillator.start(time); // if there is no release portion, stop the oscillator\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["AmplitudeEnvelope","Envelope","ToneAudioNode","omitFromObject","optionsFromArguments","readOnly","OmniOscillator","Source","Monophonic","Synth","constructor","getDefaults","arguments","options","oscillator","Object","assign","context","detune","onstop","onsilence","frequency","envelope","chain","output","keys","attack","decay","release","sustain","type","_triggerEnvelopeAttack","time","velocity","triggerAttack","start","computedAttack","toSeconds","computedDecay","stop","_triggerEnvelopeRelease","triggerRelease","getLevelAtTime","getValueAtTime","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/instrument/Synth.ts"],"sourcesContent":["import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorOptions, OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t) as OmniOscillatorOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}