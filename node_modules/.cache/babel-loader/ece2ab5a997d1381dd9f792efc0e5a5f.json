{"ast":null,"code":"/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval; // create the clock source for the first time\n\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n\n\n  _createWorker() {\n    const blob = new Blob([\n    /* javascript */\n    `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n\n\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n\n\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n\n\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n\n\n  get updateInterval() {\n    return this._updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._disposeClock();\n\n    this._type = type;\n\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this._disposeClock();\n  }\n\n}","map":{"version":3,"mappings":"AAIA;;;;AAIA,OAAM,MAAOA,MAAP,CAAa;EA2BlBC,YAAYC,QAAZ,EAAkCC,IAAlC,EAA2DC,cAA3D,EAAkF;IAEjF,KAAKC,SAAL,GAAiBH,QAAjB;IACA,KAAKI,KAAL,GAAaH,IAAb;IACA,KAAKI,eAAL,GAAuBH,cAAvB,CAJiF,CAMjF;;IACA,KAAKI,YAAL;EACA;EAED;;;;;EAGQC,aAAa;IAEpB,MAAMC,IAAI,GAAG,IAAIC,IAAJ,CAAS;IACrB;IAAgB;;wBAEK,CAAC,KAAKJ,eAAL,GAAuB,IAAxB,EAA8BK,OAA9B,CAAsC,CAAtC,CAAwC;;;;;;;;;;;;;IAHxC,CAAT,EAiBV;MAAET,IAAI,EAAE;IAAR,CAjBU,CAAb;IAkBA,MAAMU,OAAO,GAAGC,GAAG,CAACC,eAAJ,CAAoBL,IAApB,CAAhB;IACA,MAAMM,MAAM,GAAG,IAAIC,MAAJ,CAAWJ,OAAX,CAAf;IAEAG,MAAM,CAACE,SAAP,GAAmB,KAAKb,SAAL,CAAec,IAAf,CAAoB,IAApB,CAAnB;IAEA,KAAKC,OAAL,GAAeJ,MAAf;EACA;EAED;;;;;EAGQK,cAAc;IACrB,KAAKC,QAAL,GAAgBC,UAAU,CAAC,MAAK;MAC/B,KAAKF,cAAL;;MACA,KAAKhB,SAAL;IACA,CAHyB,EAGvB,KAAKE,eAAL,GAAuB,IAHA,CAA1B;EAIA;EAED;;;;;EAGQC,YAAY;IACnB,IAAI,KAAKF,KAAL,KAAe,QAAnB,EAA6B;MAC5B,IAAI;QACH,KAAKG,aAAL;MACA,CAFD,CAEE,OAAOe,CAAP,EAAU;QACX;QACA,KAAKlB,KAAL,GAAa,SAAb;;QACA,KAAKE,YAAL;MACA;IACD,CARD,MAQO,IAAI,KAAKF,KAAL,KAAe,SAAnB,EAA8B;MACpC,KAAKe,cAAL;IACA;EACD;EAED;;;;;EAGQI,aAAa;IACpB,IAAI,KAAKH,QAAT,EAAmB;MAClBI,YAAY,CAAC,KAAKJ,QAAN,CAAZ;MACA,KAAKA,QAAL,GAAgB,CAAhB;IACA;;IACD,IAAI,KAAKF,OAAT,EAAkB;MACjB,KAAKA,OAAL,CAAaO,SAAb;;MACA,KAAKP,OAAL,CAAaF,SAAb,GAAyB,IAAzB;IACA;EACD;EAED;;;;;EAGkB,IAAdd,cAAc;IACjB,OAAO,KAAKG,eAAZ;EACA;;EACiB,IAAdH,cAAc,CAACwB,QAAD,EAAkB;IACnC,KAAKrB,eAAL,GAAuBsB,IAAI,CAACC,GAAL,CAASF,QAAT,EAAmB,MAAM,KAAzB,CAAvB;;IACA,IAAI,KAAKtB,KAAL,KAAe,QAAnB,EAA6B;MAC5B,KAAKc,OAAL,CAAaW,WAAb,CAAyBF,IAAI,CAACC,GAAL,CAASF,QAAQ,GAAG,IAApB,EAA0B,CAA1B,CAAzB;IACA;EACD;EAED;;;;;EAGQ,IAAJzB,IAAI;IACP,OAAO,KAAKG,KAAZ;EACA;;EACO,IAAJH,IAAI,CAACA,IAAD,EAAwB;IAC/B,KAAKsB,aAAL;;IACA,KAAKnB,KAAL,GAAaH,IAAb;;IACA,KAAKK,YAAL;EACA;EAED;;;;;EAGAwB,OAAO;IACN,KAAKP,aAAL;EACA;;AA3IiB","names":["Ticker","constructor","callback","type","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","blob","Blob","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","bind","_worker","_createTimeout","_timeout","setTimeout","e","_disposeClock","clearTimeout","terminate","interval","Math","max","postMessage","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/Ticker.ts"],"sourcesContent":["import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}