{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\n\nexport class Solo extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n    this.name = \"Solo\";\n    const options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n    this.input = this.output = new Gain({\n      context: this.context\n    });\n\n    if (!Solo._allSolos.has(this.context)) {\n      Solo._allSolos.set(this.context, new Set());\n    }\n\n    Solo._allSolos.get(this.context).add(this); // set initially\n\n\n    this.solo = options.solo;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      solo: false\n    });\n  }\n  /**\n   * Isolates this instance and mutes all other instances of Solo.\n   * Only one instance can be soloed at a time. A soloed\n   * instance will report `solo=false` when another instance is soloed.\n   */\n\n\n  get solo() {\n    return this._isSoloed();\n  }\n\n  set solo(solo) {\n    if (solo) {\n      this._addSolo();\n    } else {\n      this._removeSolo();\n    }\n\n    Solo._allSolos.get(this.context).forEach(instance => instance._updateSolo());\n  }\n  /**\n   * If the current instance is muted, i.e. another instance is soloed\n   */\n\n\n  get muted() {\n    return this.input.gain.value === 0;\n  }\n  /**\n   * Add this to the soloed array\n   */\n\n\n  _addSolo() {\n    if (!Solo._soloed.has(this.context)) {\n      Solo._soloed.set(this.context, new Set());\n    }\n\n    Solo._soloed.get(this.context).add(this);\n  }\n  /**\n   * Remove this from the soloed array\n   */\n\n\n  _removeSolo() {\n    if (Solo._soloed.has(this.context)) {\n      Solo._soloed.get(this.context).delete(this);\n    }\n  }\n  /**\n   * Is this on the soloed array\n   */\n\n\n  _isSoloed() {\n    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);\n  }\n  /**\n   * Returns true if no one is soloed\n   */\n\n\n  _noSolos() {\n    // either does not have any soloed added\n    return !Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items\n    Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;\n  }\n  /**\n   * Solo the current instance and unsolo all other instances.\n   */\n\n\n  _updateSolo() {\n    if (this._isSoloed()) {\n      this.input.gain.value = 1;\n    } else if (this._noSolos()) {\n      // no one is soloed\n      this.input.gain.value = 1;\n    } else {\n      this.input.gain.value = 0;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    Solo._allSolos.get(this.context).delete(this);\n\n    this._removeSolo();\n\n    return this;\n  }\n\n}\n/**\n * Hold all of the solo'ed tracks belonging to a specific context\n */\n\nSolo._allSolos = new Map();\n/**\n * Hold the currently solo'ed instance(s)\n */\n\nSolo._soloed = new Map();","map":{"version":3,"mappings":"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","names":["Gain","ToneAudioNode","optionsFromArguments","Solo","constructor","getDefaults","arguments","options","input","output","context","_allSolos","has","set","Set","get","add","solo","Object","assign","_isSoloed","_addSolo","_removeSolo","forEach","instance","_updateSolo","muted","gain","value","_soloed","delete","_noSolos","size","dispose","Map"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/channel/Solo.ts"],"sourcesContent":["import { BaseContext } from \"../../core/context/BaseContext\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport interface SoloOptions extends ToneAudioNodeOptions {\n\tsolo: boolean;\n}\n\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode<SoloOptions> {\n\n\treadonly name: string = \"Solo\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param solo If the connection should be initially solo'ed.\n\t */\n\tconstructor(solo?: boolean);\n\tconstructor(options?: Partial<SoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n\t\tconst options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tif (!Solo._allSolos.has(this.context)) {\n\t\t\tSolo._allSolos.set(this.context, new Set());\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).add(this);\n\n\t\t// set initially\n\t\tthis.solo = options.solo;\n\t}\n\n\tstatic getDefaults(): SoloOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsolo: false,\n\t\t});\n\t}\n\n\t/**\n\t * Hold all of the solo'ed tracks belonging to a specific context\n\t */\n\tprivate static _allSolos: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Hold the currently solo'ed instance(s)\n\t */\n\tprivate static _soloed: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Isolates this instance and mutes all other instances of Solo.\n\t * Only one instance can be soloed at a time. A soloed\n\t * instance will report `solo=false` when another instance is soloed.\n\t */\n\tget solo(): boolean {\n\t\treturn this._isSoloed();\n\t}\n\tset solo(solo) {\n\t\tif (solo) {\n\t\t\tthis._addSolo();\n\t\t} else {\n\t\t\tthis._removeSolo();\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).forEach(instance => instance._updateSolo());\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed\n\t */\n\tget muted(): boolean {\n\t\treturn this.input.gain.value === 0;\n\t}\n\n\t/**\n\t * Add this to the soloed array\n\t */\n\tprivate _addSolo(): void {\n\t\tif (!Solo._soloed.has(this.context)) {\n\t\t\tSolo._soloed.set(this.context, new Set());\n\t\t}\n\t\t(Solo._soloed.get(this.context) as Set<Solo>).add(this);\n\t}\n\n\t/**\n\t * Remove this from the soloed array\n\t */\n\tprivate _removeSolo(): void {\n\t\tif (Solo._soloed.has(this.context)) {\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).delete(this);\n\t\t}\n\t}\n\n\t/**\n\t * Is this on the soloed array\n\t */\n\tprivate _isSoloed(): boolean {\n\t\treturn Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).has(this);\n\t}\n\n\t/**\n\t * Returns true if no one is soloed\n\t */\n\tprivate _noSolos(): boolean {\n\t\t// either does not have any soloed added\n\t\treturn !Solo._soloed.has(this.context) ||\n\t\t\t// or has a solo set but doesn't include any items\n\t\t\t(Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).size === 0);\n\t}\n\n\t/**\n\t * Solo the current instance and unsolo all other instances.\n\t */\n\tprivate _updateSolo(): void {\n\t\tif (this._isSoloed()) {\n\t\t\tthis.input.gain.value = 1;\n\t\t} else if (this._noSolos()) {\n\t\t\t// no one is soloed\n\t\t\tthis.input.gain.value = 1;\n\t\t} else {\n\t\t\tthis.input.gain.value = 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).delete(this);\n\t\tthis._removeSolo();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}