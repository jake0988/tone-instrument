{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\n\nexport class IntervalTimeline extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n\n    this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n\n    this._length = 0;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n\n\n  add(event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    let node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n\n\n  remove(event) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(event.time, results);\n\n      for (const node of results) {\n        if (node.event === event) {\n          this._removeNode(node);\n\n          this._length--;\n          break;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of items in the timeline.\n   * @readOnly\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    this.forEachFrom(after, event => this.remove(event));\n    return this;\n  }\n  /**\n   * Set the root node as the given node\n   */\n\n\n  _setRoot(node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  }\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n\n\n  _replaceNodeInParent(node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  }\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n\n\n  _removeNode(node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      const balance = node.getBalance();\n      let replacement;\n      let temp = null;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n\n    node.dispose();\n  }\n  /**\n   * Rotate the tree to the left\n   */\n\n\n  _rotateLeft(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    const pivotNode = node.right;\n\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Rotate the tree to the right\n   */\n\n\n  _rotateRight(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    const pivotNode = node.left;\n\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Balance the BST\n   */\n\n\n  _rebalance(node) {\n    const balance = node.getBalance();\n\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  }\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n\n\n  get(time) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        let max = results[0];\n\n        for (let i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    if (this._root !== null) {\n      const allNodes = [];\n\n      this._root.traverse(node => allNodes.push(node));\n\n      allNodes.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.searchAfter(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._root !== null) {\n      this._root.traverse(node => node.dispose());\n    }\n\n    this._root = null;\n    return this;\n  }\n\n} //-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n\nclass IntervalNode {\n  constructor(low, high, event) {\n    // the nodes to the left\n    this._left = null; // the nodes to the right\n\n    this._right = null; // the parent node\n\n    this.parent = null; // the number of child nodes\n\n    this.height = 0;\n    this.event = event; // the low value\n\n    this.low = low; // the high value\n\n    this.high = high; // the high value for this and all child nodes\n\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n\n\n  insert(node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  }\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  search(point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  }\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  searchAfter(point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  }\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n\n\n  traverse(callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateHeight() {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateMax() {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  }\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n\n\n  getBalance() {\n    let balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  }\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n\n\n  isLeftChild() {\n    return this.parent !== null && this.parent.left === this;\n  }\n  /**\n   * get/set the left node\n   */\n\n\n  get left() {\n    return this._left;\n  }\n\n  set left(node) {\n    this._left = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * get/set the right node\n   */\n\n\n  get right() {\n    return this._right;\n  }\n\n  set right(node) {\n    this._right = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * null out references.\n   */\n\n\n  dispose() {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Tone","isDefined","assert","IntervalTimeline","constructor","add","event","time","duration","valueOf","node","IntervalNode","_root","insert","_length","updateHeight","updateMax","_rebalance","parent","remove","results","search","_removeNode","length","cancel","after","forEachFrom","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","balance","getBalance","temp","dispose","_rotateLeft","pivotNode","_rotateRight","get","max","i","low","forEach","callback","allNodes","traverse","push","forEachAtTime","searchAfter","high","point","height","Math","_left","_right"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/util/IntervalTimeline.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}