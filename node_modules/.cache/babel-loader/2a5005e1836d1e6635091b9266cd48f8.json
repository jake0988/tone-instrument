{"ast":null,"code":"import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n\n\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n\n\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n\n\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n\n        this._scheduled.push(sched); // if the transport is already started\n        // and the time is greater than where the transport is\n\n\n        if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        assertContextRunning(this.context);\n\n        this._start(computedTime, offset, duration);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n\n\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n        this._scheduled.push(sched);\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n\n\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n\n      this._restart(time, offset, duration);\n    }\n\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n\n\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n\n    this._scheduled = [];\n\n    this._state.cancel(0); // stop it also\n\n\n    this._stop(0);\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n\n    this._volume.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Volume","ToneAudioNode","defaultArg","noOp","readOnly","StateTimeline","isDefined","isUndef","assert","assertContextRunning","GT","Source","constructor","options","undefined","_state","memory","increasing","_volume","output","context","mute","volume","onstop","getDefaults","Object","assign","state","_synced","transport","getValueAtTime","seconds","now","_clampToCurrentTime","time","Math","max","currentTime","start","offset","duration","computedTime","toSeconds","get","cancel","setStateAtTime","log","restart","event","sched","schedule","t","_start","_scheduled","push","getSecondsAtTime","immediate","_syncedStart","stop","getNextState","_stop","bind","_restart","sync","stateEvent","startOffset","_syncedStop","sampleTime","on","unsync","off","forEach","id","clear","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/Source.ts"],"sourcesContent":["import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(time: Seconds, offset?: Time, duration?: Time): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(GT(computedTime, (this._state.get(computedTime) as StateTimelineEvent).time), \"Start time must be strictly greater than previous start time\");\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (this.context.transport.state === \"started\" && \n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}