{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport class FMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"FMOscillator\";\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: 0,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.detune = this._carrier.detune;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.modulationIndex\n    }); // connections\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n\n    this.detune.connect(this._modulator.detune);\n    readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationIndex: 2,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n\n    return this;\n  }\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Gain","optionsFromArguments","readOnly","Multiply","Signal","Source","Oscillator","generateWaveform","FMOscillator","constructor","getDefaults","arguments","context","gain","options","_carrier","detune","frequency","onstop","phase","type","units","value","_modulator","modulationType","harmonicity","modulationIndex","connect","chain","_modulationNode","output","Object","assign","_start","time","start","_stop","stop","_restart","restart","baseType","partialCount","partials","asArray","length","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/FMOscillator.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFMConstructorOptions, FMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const fmOsc = new Tone.FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}