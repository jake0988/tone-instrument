{"ast":null,"code":"import { ToneAudioWorklet } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\n\nexport class BitCrusher extends Effect {\n  constructor() {\n    super(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n    this.name = \"BitCrusher\";\n    const options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n    this._bitCrusherWorklet = new BitCrusherWorklet({\n      context: this.context,\n      bits: options.bits\n    }); // connect it up\n\n    this.connectEffect(this._bitCrusherWorklet);\n    this.bits = this._bitCrusherWorklet.bits;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      bits: 4\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._bitCrusherWorklet.dispose();\n\n    return this;\n  }\n\n}\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\n\nclass BitCrusherWorklet extends ToneAudioWorklet {\n  constructor() {\n    super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n    this.name = \"BitCrusherWorklet\";\n    const options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    this.bits = new Param({\n      context: this.context,\n      value: options.bits,\n      units: \"positive\",\n      minValue: 1,\n      maxValue: 16,\n      param: this._dummyParam,\n      swappable: true\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioWorklet.getDefaults(), {\n      bits: 12\n    });\n  }\n\n  _audioWorkletName() {\n    return workletName;\n  }\n\n  onReady(node) {\n    connectSeries(this.input, node, this.output);\n    const bits = node.parameters.get(\"bits\");\n    this.bits.setParam(bits);\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.bits.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ToneAudioWorklet","Effect","Gain","optionsFromArguments","connectSeries","Param","workletName","BitCrusher","constructor","getDefaults","arguments","options","_bitCrusherWorklet","BitCrusherWorklet","context","bits","connectEffect","Object","assign","dispose","input","output","value","units","minValue","maxValue","param","_dummyParam","swappable","_audioWorkletName","onReady","node","parameters","get","setParam"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/effect/BitCrusher.ts"],"sourcesContent":["import { ToneAudioWorklet, ToneAudioWorkletOptions } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n\nexport interface BitCrusherOptions extends EffectOptions {\n\tbits: Positive;\n}\n\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n * \n * @category Effect\n */\nexport class BitCrusher extends Effect<BitCrusherOptions> {\n\n\treadonly name: string = \"BitCrusher\";\n\n\t/**\n\t * The bit depth of the effect\n\t * @min 1\n\t * @max 16\n\t */\n\treadonly bits: Param<\"positive\">;\n\n\t/**\n\t * The node which does the bit crushing effect. Runs in an AudioWorklet when possible.\n\t */\n\tprivate _bitCrusherWorklet: BitCrusherWorklet;\n\n\tconstructor(bits?: Positive);\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n\t\tconst options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n\n\t\tthis._bitCrusherWorklet = new BitCrusherWorklet({\n\t\t\tcontext: this.context,\n\t\t\tbits: options.bits,\n\t\t});\n\t\t// connect it up\n\t\tthis.connectEffect(this._bitCrusherWorklet);\n\n\t\tthis.bits = this._bitCrusherWorklet.bits;\n\t}\n\n\tstatic getDefaults(): BitCrusherOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbits: 4,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._bitCrusherWorklet.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface BitCrusherWorkletOptions extends ToneAudioWorkletOptions {\n\tbits: number;\n}\n\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet<BitCrusherWorkletOptions> {\n\n\treadonly name: string = \"BitCrusherWorklet\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\treadonly bits: Param<\"positive\">;\n\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.bits = new Param<\"positive\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.bits,\n\t\t\tunits: \"positive\",\n\t\t\tminValue: 1,\n\t\t\tmaxValue: 16,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\t}\n\n\tstatic getDefaults(): BitCrusherWorkletOptions {\n\t\treturn Object.assign(ToneAudioWorklet.getDefaults(), {\n\t\t\tbits: 12,\n\t\t});\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst bits = node.parameters.get(\"bits\") as AudioParam;\n\t\tthis.bits.setParam(bits);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.bits.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}