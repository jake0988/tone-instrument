{"ast":null,"code":"import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\n\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(this._source, this._gainNode);\n\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n\n\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    }); // set some values initially\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n    this._internalChannels.push(this._source);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n\n\n  get curve() {\n    return this._curve;\n  }\n\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n\n\n  start(time, offset, duration) {\n    let gain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time); // apply the gain envelope\n\n    this._startGain(computedTime, gain); // if it's a loop the default offset is the loopstart point\n\n\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // make sure the offset is not less than 0\n\n\n    let computedOffset = Math.max(this.toSeconds(offset), 0); // start the buffer source\n\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart; // move the offset back\n\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      } // when the offset is very close to the duration, set it to 0\n\n\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    } // this.buffer.loaded would have return false if the AudioBuffer was undefined\n\n\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n\n      this._source.start(computedTime, computedOffset);\n    } // if a duration is given, schedule a stop\n\n\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration); // make sure it's never negative\n\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n\n    return this;\n  }\n\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n\n      this._source.stop(this.toSeconds(time));\n\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n\n\n  get loopStart() {\n    return this._source.loopStart;\n  }\n\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n\n\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n\n\n  get loop() {\n    return this._source.loop;\n  }\n\n  set loop(loop) {\n    this._source.loop = loop;\n\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n\n    this._source.disconnect();\n\n    this._buffer.dispose();\n\n    this.playbackRate.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,kCAAxB;AACA,SAASC,KAAT,QAAsB,0BAAtB;AACA,SAASC,eAAT,QAAgC,oCAAhC;AAEA,SAASC,UAAT,EAAqBC,oBAArB,QAAiD,0BAAjD;AACA,SAASC,IAAT,QAAqB,2BAArB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,aAAT,QAAwE,kBAAxE;AACA,SAASC,EAAT,EAAaC,GAAb,EAAkBC,EAAlB,QAA4B,sBAA5B;AAiBA;;;;;AAIA,OAAM,MAAOC,gBAAP,SAAgCJ,aAAhC,CAAsE;EAgC3EK;IAEC,MAAMT,oBAAoB,CAACQ,gBAAgB,CAACE,WAAjB,EAAD,EAAiCC,SAAjC,EAA4C,CAAC,KAAD,EAAQ,QAAR,CAA5C,CAA1B;IAhCQ,YAAe,kBAAf;IAET;;;;IAGQ,eAAU,KAAKC,OAAL,CAAaC,kBAAb,EAAV;IACE,yBAAoB,CAAC,KAAKC,OAAN,CAApB;IAYV;;;;IAGQ,sBAAiB,KAAjB;IACA,sBAAiB,KAAjB;IAWP,MAAMC,OAAO,GAAGf,oBAAoB,CAACQ,gBAAgB,CAACE,WAAjB,EAAD,EAAiCC,SAAjC,EAA4C,CAAC,KAAD,EAAQ,QAAR,CAA5C,CAApC;IAEAf,OAAO,CAAC,KAAKkB,OAAN,EAAe,KAAKE,SAApB,CAAP;;IACA,KAAKF,OAAL,CAAaG,OAAb,GAAuB,MAAM,KAAKC,WAAL,EAA7B;IAEA;;;;;IAGA,KAAKC,YAAL,GAAoB,IAAItB,KAAJ,CAAU;MAC7Be,OAAO,EAAE,KAAKA,OADe;MAE7BQ,KAAK,EAAE,KAAKN,OAAL,CAAaK,YAFS;MAG7BE,KAAK,EAAE,UAHsB;MAI7BC,KAAK,EAAEP,OAAO,CAACI;IAJc,CAAV,CAApB,CAXD,CAkBC;;IACA,KAAKI,IAAL,GAAYR,OAAO,CAACQ,IAApB;IACA,KAAKC,SAAL,GAAiBT,OAAO,CAACS,SAAzB;IACA,KAAKC,OAAL,GAAeV,OAAO,CAACU,OAAvB;IACA,KAAKC,OAAL,GAAe,IAAI5B,eAAJ,CAAoBiB,OAAO,CAACY,GAA5B,EAAiCZ,OAAO,CAACa,MAAzC,EAAiDb,OAAO,CAACc,OAAzD,CAAf;;IAEA,KAAKC,iBAAL,CAAuBC,IAAvB,CAA4B,KAAKjB,OAAjC;EACA;;EAEiB,OAAXJ,WAAW;IACjB,OAAOsB,MAAM,CAACC,MAAP,CAAc7B,aAAa,CAACM,WAAd,EAAd,EAA2C;MACjDiB,GAAG,EAAE,IAAI7B,eAAJ,EAD4C;MAEjDyB,IAAI,EAAE,KAF2C;MAGjDE,OAAO,EAAE,CAHwC;MAIjDD,SAAS,EAAE,CAJsC;MAKjDI,MAAM,EAAE3B,IALyC;MAMjD4B,OAAO,EAAE5B,IANwC;MAOjDkB,YAAY,EAAE;IAPmC,CAA3C,CAAP;EASA;EAED;;;;;EAGU,IAANe,MAAM;IACT,OAAO,KAAKC,OAAZ;EACA;;EACS,IAAND,MAAM,CAACE,CAAD,EAAQ;IACjB,KAAKD,OAAL,GAAeC,CAAf;EACA;EAED;;;;;EAGW,IAAPC,OAAO;IACV,OAAO,KAAKC,QAAZ;EACA;;EACU,IAAPD,OAAO,CAACD,CAAD,EAAQ;IAClB,KAAKE,QAAL,GAAgBF,CAAhB;EACA;EAED;;;;;EAGS,IAALG,KAAK;IACR,OAAO,KAAKC,MAAZ;EACA;;EACQ,IAALD,KAAK,CAACH,CAAD,EAAE;IACV,KAAKI,MAAL,GAAcJ,CAAd;EACA;EAED;;;;;;;;;EAOAK,KAAK,CAACC,IAAD,EAAcC,MAAd,EAA6BC,QAA7B,EAAkE;IAAA,IAApBC,IAAoB,uEAAD,CAAC;IACtE1C,MAAM,CAAC,KAAK2C,MAAL,CAAYC,MAAb,EAAqB,wCAArB,CAAN;IACA,MAAMC,YAAY,GAAG,KAAKC,SAAL,CAAeP,IAAf,CAArB,CAFsE,CAItE;;IACA,KAAKQ,UAAL,CAAgBF,YAAhB,EAA8BH,IAA9B,EALsE,CAOtE;;;IACA,IAAI,KAAKtB,IAAT,EAAe;MACdoB,MAAM,GAAG5C,UAAU,CAAC4C,MAAD,EAAS,KAAKnB,SAAd,CAAnB;IACA,CAFD,MAEO;MACN;MACAmB,MAAM,GAAG5C,UAAU,CAAC4C,MAAD,EAAS,CAAT,CAAnB;IACA,CAbqE,CActE;;;IACA,IAAIQ,cAAc,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKJ,SAAL,CAAeN,MAAf,CAAT,EAAiC,CAAjC,CAArB,CAfsE,CAiBtE;;IACA,IAAI,KAAKpB,IAAT,EAAe;MACd;MACA,MAAME,OAAO,GAAG,KAAKwB,SAAL,CAAe,KAAKxB,OAApB,KAAgC,KAAKqB,MAAL,CAAYF,QAA5D;MACA,MAAMpB,SAAS,GAAG,KAAKyB,SAAL,CAAe,KAAKzB,SAApB,CAAlB;MACA,MAAM8B,YAAY,GAAG7B,OAAO,GAAGD,SAA/B,CAJc,CAKd;;MACA,IAAIlB,GAAG,CAAC6C,cAAD,EAAiB1B,OAAjB,CAAP,EAAkC;QACjC0B,cAAc,GAAI,CAACA,cAAc,GAAG3B,SAAlB,IAA+B8B,YAAhC,GAAgD9B,SAAjE;MACA,CARa,CASd;;;MACA,IAAInB,EAAE,CAAC8C,cAAD,EAAiB,KAAKL,MAAL,CAAYF,QAA7B,CAAN,EAA8C;QAC7CO,cAAc,GAAG,CAAjB;MACA;IACD,CA/BqE,CAiCtE;;;IACA,KAAKrC,OAAL,CAAagC,MAAb,GAAsB,KAAKA,MAAL,CAAYS,GAAZ,EAAtB;IACA,KAAKzC,OAAL,CAAaW,OAAb,GAAuB,KAAKwB,SAAL,CAAe,KAAKxB,OAApB,KAAgC,KAAKqB,MAAL,CAAYF,QAAnE;;IACA,IAAIrC,EAAE,CAAC4C,cAAD,EAAiB,KAAKL,MAAL,CAAYF,QAA7B,CAAN,EAA8C;MAC7C,KAAKY,cAAL,GAAsB,IAAtB;;MACA,KAAK1C,OAAL,CAAa2B,KAAb,CAAmBO,YAAnB,EAAiCG,cAAjC;IACA,CAvCqE,CAyCtE;;;IACA,IAAIjD,SAAS,CAAC0C,QAAD,CAAb,EAAyB;MACxB,IAAIa,WAAW,GAAG,KAAKR,SAAL,CAAeL,QAAf,CAAlB,CADwB,CAExB;;MACAa,WAAW,GAAGL,IAAI,CAACC,GAAL,CAASI,WAAT,EAAsB,CAAtB,CAAd;MACA,KAAKC,IAAL,CAAUV,YAAY,GAAGS,WAAzB;IACA;;IAED,OAAO,IAAP;EACA;;EAESvC,WAAW,CAACwB,IAAD,EAAe;IACnC,IAAI,CAAC,KAAKiB,cAAN,IAAwB,KAAKH,cAAjC,EAAiD;MAChD,KAAKG,cAAL,GAAsB,IAAtB;;MACA,KAAK7C,OAAL,CAAa4C,IAAb,CAAkB,KAAKT,SAAL,CAAeP,IAAf,CAAlB;;MACA,KAAKkB,QAAL;IACA;EACD;EAED;;;;;EAGa,IAATpC,SAAS;IACZ,OAAO,KAAKV,OAAL,CAAaU,SAApB;EACA;;EACY,IAATA,SAAS,CAACA,SAAD,EAAgB;IAC5B,KAAKV,OAAL,CAAaU,SAAb,GAAyB,KAAKyB,SAAL,CAAezB,SAAf,CAAzB;EACA;EAED;;;;;EAGW,IAAPC,OAAO;IACV,OAAO,KAAKX,OAAL,CAAaW,OAApB;EACA;;EACU,IAAPA,OAAO,CAACA,OAAD,EAAc;IACxB,KAAKX,OAAL,CAAaW,OAAb,GAAuB,KAAKwB,SAAL,CAAexB,OAAf,CAAvB;EACA;EAED;;;;;EAGU,IAANqB,MAAM;IACT,OAAO,KAAKpB,OAAZ;EACA;;EACS,IAANoB,MAAM,CAACA,MAAD,EAAwB;IACjC,KAAKpB,OAAL,CAAamC,GAAb,CAAiBf,MAAjB;EACA;EAED;;;;;EAGQ,IAAJvB,IAAI;IACP,OAAO,KAAKT,OAAL,CAAaS,IAApB;EACA;;EACO,IAAJA,IAAI,CAACA,IAAD,EAAc;IACrB,KAAKT,OAAL,CAAaS,IAAb,GAAoBA,IAApB;;IACA,IAAI,KAAKiC,cAAT,EAAyB;MACxB,KAAKM,UAAL;IACA;EACD;EAED;;;;;EAGAC,OAAO;IACN,MAAMA,OAAN;IACA,KAAKjD,OAAL,CAAaG,OAAb,GAAuB,IAAvB;;IACA,KAAKH,OAAL,CAAakD,UAAb;;IACA,KAAKtC,OAAL,CAAaqC,OAAb;;IACA,KAAK5C,YAAL,CAAkB4C,OAAlB;IACA,OAAO,IAAP;EACA;;AA7N0E","names":["connect","Param","ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isDefined","assert","OneShotSource","EQ","GTE","LT","ToneBufferSource","constructor","getDefaults","arguments","context","createBufferSource","_source","options","_gainNode","onended","_stopSource","playbackRate","param","units","value","loop","loopStart","loopEnd","_buffer","url","onload","onerror","_internalChannels","push","Object","assign","fadeIn","_fadeIn","t","fadeOut","_fadeOut","curve","_curve","start","time","offset","duration","gain","buffer","loaded","computedTime","toSeconds","_startGain","computedOffset","Math","max","loopDuration","get","_sourceStarted","computedDur","stop","_sourceStopped","_onended","set","cancelStop","dispose","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/buffer/ToneBufferSource.ts"],"sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(url?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}