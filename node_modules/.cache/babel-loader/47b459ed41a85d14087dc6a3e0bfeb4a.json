{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Sequence extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n\n    this._events = [];\n    /**\n     * The proxied array\n     */\n\n    this._eventsArray = [];\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events; // set all of the values\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n\n\n  _seqCallback(time, value) {\n    if (value !== null) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n\n\n  get events() {\n    return this._events;\n  }\n\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n\n\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n\n  stop(time) {\n    this._part.stop(time);\n\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n\n\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n\n\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n\n        this._eventsUpdated(); // return true to accept the changes\n\n\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n\n\n  _eventsUpdated() {\n    this._part.clear();\n\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd\n\n\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n\n\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n\n\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n\n\n  clear() {\n    this._part.clear();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._part.dispose();\n\n    return this;\n  } //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n\n\n  get loop() {\n    return this._part.loop;\n  }\n\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(index) {\n    this._loopEnd = index;\n\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n\n  get startOffset() {\n    return this._part.startOffset;\n  }\n\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n\n  get probability() {\n    return this._part.probability;\n  }\n\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n\n  get progress() {\n    return this._part.progress;\n  }\n\n  get humanize() {\n    return this._part.humanize;\n  }\n\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n\n\n  get length() {\n    return this._part.length;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,QAA2B,oBAA3B;AAEA,SAASC,cAAT,EAAyBC,oBAAzB,QAAqD,uBAArD;AACA,SAASC,OAAT,EAAkBC,QAAlB,QAAkC,wBAAlC;AACA,SAASC,IAAT,QAAqB,QAArB;AACA,SAASC,SAAT,QAA+D,aAA/D;AAWA;;;;;;;;;;;;;;;;;AAgBA,OAAM,MAAOC,QAAP,SAAyCD,SAAzC,CAA6D;EAsClEE;IAEC,MAAMN,oBAAoB,CAACK,QAAQ,CAACE,WAAT,EAAD,EAAyBC,SAAzB,EAAoC,CAAC,UAAD,EAAa,QAAb,EAAuB,aAAvB,CAApC,CAA1B;IAtCQ,YAAe,UAAf;IAOT;;;;IAGQ,aAAc,IAAIL,IAAJ,CAAS;MAC9BM,QAAQ,EAAE,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CADoB;MAE9BC,OAAO,EAAE,KAAKA;IAFgB,CAAT,CAAd;IAKR;;;;IAGQ,eAA+C,EAA/C;IAER;;;;IAGQ,oBAAoD,EAApD;IAgBP,MAAMC,OAAO,GAAGb,oBAAoB,CAACK,QAAQ,CAACE,WAAT,EAAD,EAAyBC,SAAzB,EAAoC,CAAC,UAAD,EAAa,QAAb,EAAuB,aAAvB,CAApC,CAApC;IAEA,KAAKM,YAAL,GAAoB,KAAKC,OAAL,CAAaF,OAAO,CAACG,WAArB,CAApB;IAEA,KAAKC,MAAL,GAAcJ,OAAO,CAACI,MAAtB,CAPD,CASC;;IACA,KAAKC,IAAL,GAAYL,OAAO,CAACK,IAApB;IACA,KAAKC,SAAL,GAAiBN,OAAO,CAACM,SAAzB;IACA,KAAKC,OAAL,GAAeP,OAAO,CAACO,OAAvB;IACA,KAAKC,YAAL,GAAoBR,OAAO,CAACQ,YAA5B;IACA,KAAKC,WAAL,GAAmBT,OAAO,CAACS,WAA3B;IACA,KAAKC,QAAL,GAAgBV,OAAO,CAACU,QAAxB;IACA,KAAKC,IAAL,GAAYX,OAAO,CAACW,IAApB;IACA,KAAKH,YAAL,GAAoBR,OAAO,CAACQ,YAA5B;EACA;;EAEiB,OAAXd,WAAW;IACjB,OAAOkB,MAAM,CAACC,MAAP,CAAc3B,cAAc,CAACK,SAAS,CAACG,WAAV,EAAD,EAA0B,CAAC,OAAD,CAA1B,CAA5B,EAAkE;MACxEU,MAAM,EAAE,EADgE;MAExEC,IAAI,EAAE,IAFkE;MAGxEE,OAAO,EAAE,CAH+D;MAIxED,SAAS,EAAE,CAJ6D;MAKxEH,WAAW,EAAE;IAL2D,CAAlE,CAAP;EAOA;EAED;;;;;EAGQN,YAAY,CAACiB,IAAD,EAAgBC,KAAhB,EAA0B;IAC7C,IAAIA,KAAK,KAAK,IAAd,EAAoB;MACnB,KAAKnB,QAAL,CAAckB,IAAd,EAAoBC,KAApB;IACA;EACD;EAED;;;;;EAGU,IAANX,MAAM;IACT,OAAO,KAAKY,OAAZ;EACA;;EACS,IAANZ,MAAM,CAACa,CAAD,EAAE;IACX,KAAKC,KAAL;IACA,KAAKC,YAAL,GAAoBF,CAApB;IACA,KAAKD,OAAL,GAAe,KAAKI,eAAL,CAAqB,KAAKD,YAA1B,CAAf;;IACA,KAAKE,cAAL;EACA;EAED;;;;;;;EAKAC,KAAK,CAACR,IAAD,EAAuBS,MAAvB,EAAsC;IAC1C,KAAKC,KAAL,CAAWF,KAAX,CAAiBR,IAAjB,EAAuBS,MAAM,GAAG,KAAKE,UAAL,CAAgBF,MAAhB,CAAH,GAA6BA,MAA1D;;IACA,OAAO,IAAP;EACA;EAED;;;;;;EAIAG,IAAI,CAACZ,IAAD,EAAqB;IACxB,KAAKU,KAAL,CAAWE,IAAX,CAAgBZ,IAAhB;;IACA,OAAO,IAAP;EACA;EAED;;;;;;;EAKe,IAAXX,WAAW;IACd,OAAO,IAAIlB,UAAJ,CAAe,KAAKc,OAApB,EAA6B,KAAKE,YAAlC,EAAgD0B,SAAhD,EAAP;EACA;EAED;;;;;EAGQP,eAAe,CAACQ,KAAD,EAAa;IACnC,OAAO,IAAIC,KAAJ,CAAUD,KAAV,EAAiB;MACvBE,GAAG,EAAE,CAACC,MAAD,EAAgBC,QAAhB,KAA8C;QAClD;QACA,OAAOD,MAAM,CAACC,QAAD,CAAb;MACA,CAJsB;MAKvBC,GAAG,EAAE,CAACF,MAAD,EAAgBC,QAAhB,EAAuCjB,KAAvC,KAA8D;QAClE,IAAI1B,QAAQ,CAAC2C,QAAD,CAAR,IAAsBE,QAAQ,CAACC,QAAQ,CAACH,QAAD,EAAW,EAAX,CAAT,CAAlC,EAA4D;UAC3D,IAAI5C,OAAO,CAAC2B,KAAD,CAAX,EAAoB;YACnBgB,MAAM,CAACC,QAAD,CAAN,GAAmB,KAAKZ,eAAL,CAAqBL,KAArB,CAAnB;UACA,CAFD,MAEO;YACNgB,MAAM,CAACC,QAAD,CAAN,GAAmBjB,KAAnB;UACA;QACD,CAND,MAMO;UACNgB,MAAM,CAACC,QAAD,CAAN,GAAmBjB,KAAnB;QACA;;QACD,KAAKM,cAAL,GAVkE,CAWlE;;;QACA,OAAO,IAAP;MACA;IAlBsB,CAAjB,CAAP;EAoBA;EAED;;;;;EAGQA,cAAc;IACrB,KAAKG,KAAL,CAAWN,KAAX;;IACA,KAAKkB,mBAAL,CAAyB,KAAKjB,YAA9B,EAA4C,KAAKlB,YAAjD,EAA+D,KAAKoC,WAApE,EAFqB,CAGrB;;;IACA,KAAK9B,OAAL,GAAe,KAAKA,OAApB;EACA;EAED;;;;;EAGQ6B,mBAAmB,CAACE,QAAD,EAAkBnC,WAAlB,EAAsCkC,WAAtC,EAAwD;IAClFC,QAAQ,CAACC,OAAT,CAAiB,CAACxB,KAAD,EAAQyB,KAAR,KAAiB;MACjC,MAAMC,WAAW,GAAGD,KAAK,GAAIrC,WAAT,GAAwBkC,WAA5C;;MACA,IAAIjD,OAAO,CAAC2B,KAAD,CAAX,EAAoB;QACnB,KAAKqB,mBAAL,CAAyBrB,KAAzB,EAAgCZ,WAAW,GAAGY,KAAK,CAAC2B,MAApD,EAA4DD,WAA5D;MACA,CAFD,MAEO;QACN,MAAME,SAAS,GAAG,IAAI1D,UAAJ,CAAe,KAAKc,OAApB,EAA6B0C,WAA7B,EAA0C,GAA1C,EAA+Cd,SAA/C,EAAlB;;QACA,KAAKH,KAAL,CAAWoB,GAAX,CAAeD,SAAf,EAA0B5B,KAA1B;MACA;IACD,CARD;EASA;EAED;;;;;;;EAKQU,UAAU,CAACe,KAAD,EAAc;IAC/B,OAAO,IAAIvD,UAAJ,CAAe,KAAKc,OAApB,EAA6ByC,KAAK,GAAI,KAAKvC,YAAd,GAA8B,KAAKoC,WAAhE,EAA6EV,SAA7E,EAAP;EACA;EAED;;;;;EAGAT,KAAK;IACJ,KAAKM,KAAL,CAAWN,KAAX;;IACA,OAAO,IAAP;EACA;;EAED2B,OAAO;IACN,MAAMA,OAAN;;IACA,KAAKrB,KAAL,CAAWqB,OAAX;;IACA,OAAO,IAAP;EACA,CA9LiE,CAgMlE;EACA;EACA;;;EAEQ,IAAJxC,IAAI;IACP,OAAO,KAAKmB,KAAL,CAAWnB,IAAlB;EACA;;EACO,IAAJA,IAAI,CAACyC,CAAD,EAAE;IACT,KAAKtB,KAAL,CAAWnB,IAAX,GAAkByC,CAAlB;EACA;EAED;;;;;EAGa,IAATxC,SAAS;IACZ,OAAO,KAAKyC,UAAZ;EACA;;EACY,IAATzC,SAAS,CAACkC,KAAD,EAAM;IAClB,KAAKO,UAAL,GAAkBP,KAAlB;IACA,KAAKhB,KAAL,CAAWlB,SAAX,GAAuB,KAAKmB,UAAL,CAAgBe,KAAhB,CAAvB;EACA;EAED;;;;;EAGW,IAAPjC,OAAO;IACV,OAAO,KAAKyC,QAAZ;EACA;;EACU,IAAPzC,OAAO,CAACiC,KAAD,EAAM;IAChB,KAAKQ,QAAL,GAAgBR,KAAhB;;IACA,IAAIA,KAAK,KAAK,CAAd,EAAiB;MAChB,KAAKhB,KAAL,CAAWjB,OAAX,GAAqB,KAAKkB,UAAL,CAAgB,KAAKN,YAAL,CAAkBuB,MAAlC,CAArB;IACA,CAFD,MAEO;MACN,KAAKlB,KAAL,CAAWjB,OAAX,GAAqB,KAAKkB,UAAL,CAAgBe,KAAhB,CAArB;IACA;EACD;;EAEc,IAAXH,WAAW;IACd,OAAO,KAAKb,KAAL,CAAWa,WAAlB;EACA;;EACc,IAAXA,WAAW,CAACf,KAAD,EAAM;IACpB,KAAKE,KAAL,CAAWa,WAAX,GAAyBf,KAAzB;EACA;;EAEe,IAAZd,YAAY;IACf,OAAO,KAAKgB,KAAL,CAAWhB,YAAlB;EACA;;EACe,IAAZA,YAAY,CAACyC,IAAD,EAAK;IACpB,KAAKzB,KAAL,CAAWhB,YAAX,GAA0ByC,IAA1B;EACA;;EAEc,IAAXxC,WAAW;IACd,OAAO,KAAKe,KAAL,CAAWf,WAAlB;EACA;;EACc,IAAXA,WAAW,CAACyC,IAAD,EAAK;IACnB,KAAK1B,KAAL,CAAWf,WAAX,GAAyByC,IAAzB;EACA;;EAEW,IAARC,QAAQ;IACX,OAAO,KAAK3B,KAAL,CAAW2B,QAAlB;EACA;;EAEW,IAARzC,QAAQ;IACX,OAAO,KAAKc,KAAL,CAAWd,QAAlB;EACA;;EACW,IAARA,QAAQ,CAAC0C,SAAD,EAAU;IACrB,KAAK5B,KAAL,CAAWd,QAAX,GAAsB0C,SAAtB;EACA;EAED;;;;;EAGU,IAANV,MAAM;IACT,OAAO,KAAKlB,KAAL,CAAWkB,MAAlB;EACA;;AA1QiE","names":["TicksClass","omitFromObject","optionsFromArguments","isArray","isString","Part","ToneEvent","Sequence","constructor","getDefaults","arguments","callback","_seqCallback","bind","context","options","_subdivision","toTicks","subdivision","events","loop","loopStart","loopEnd","playbackRate","probability","humanize","mute","Object","assign","time","value","_events","s","clear","_eventsArray","_createSequence","_eventsUpdated","start","offset","_part","_indexTime","stop","toSeconds","array","Proxy","get","target","property","set","isFinite","parseInt","_rescheduleSequence","startOffset","sequence","forEach","index","eventOffset","length","startTime","add","dispose","l","_loopStart","_loopEnd","rate","prob","progress","variation"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/event/Sequence.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | Array<T | Array<T | Array<T | Array<T | T[]>>>>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}