{"ast":null,"code":"import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\n\nexport class TickParam extends Param {\n  constructor() {\n    super(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n\n    this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n\n    this._multiplier = 1;\n    const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]); // set the multiplier\n\n    this._multiplier = options.multiplier; // clear the ticks from the beginning\n\n    this._events.cancel(0); // set an initial event\n\n\n    this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: this._fromType(options.value)\n    });\n\n    this.setValueAtTime(options.value, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign(Param.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n\n  setTargetAtTime(value, time, constant) {\n    // approximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n\n    const computedValue = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time);\n\n    const segments = Math.round(Math.max(1 / constant, 1));\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = constant * i + time;\n\n      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.setValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.linearRampToValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    // aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n\n    const computedVal = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time); // approx 10 segments per second\n\n\n    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    const segmentDur = (time - prevEvent.time) / segments;\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = segmentDur * i + prevEvent.time;\n\n      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  event The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  _getTicksUntilEvent(event, time) {\n    if (event === null) {\n      event = {\n        ticks: 0,\n        time: 0,\n        type: \"setValueAtTime\",\n        value: 0\n      };\n    } else if (isUndef(event.ticks)) {\n      const previousEvent = this._events.previousEvent(event);\n\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n\n    const val0 = this._fromType(this.getValueAtTime(event.time));\n\n    let val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value\n\n\n    const onTheLineEvent = this._events.get(time);\n\n    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n    }\n\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  time The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const event = this._events.get(computedTime);\n\n    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n  }\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param ticks The number of ticks to calculate\n   * @param  time The time to get the next tick from\n   * @return The duration of the number of ticks from the given time in seconds\n   */\n\n\n  getDurationOfTicks(ticks, time) {\n    const computedTime = this.toSeconds(time);\n    const currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - computedTime;\n  }\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @return The time that the tick occurs.\n   */\n\n\n  getTimeOfTick(tick) {\n    const before = this._events.get(tick, \"ticks\");\n\n    const after = this._events.getAfter(tick, \"ticks\");\n\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n      const val0 = this._fromType(this.getValueAtTime(before.time));\n\n      const val1 = this._fromType(this.getValueAtTime(after.time));\n\n      const delta = (val1 - val0) / (after.time - before.time);\n      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      const sol1 = (-val0 + k) / delta;\n      const sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  }\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  ticks The number of ticks to convert to seconds.\n   * @param  when  When along the automation timeline to convert the ticks.\n   * @return The duration in seconds of the ticks.\n   */\n\n\n  ticksToTime(ticks, when) {\n    return this.getDurationOfTicks(ticks, when);\n  }\n  /**\n   * The inverse of [[ticksToTime]]. Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  duration The time interval to convert to ticks.\n   * @param  when When along the automation timeline to convert the ticks.\n   * @return The duration in ticks.\n   */\n\n\n  timeToTicks(duration, when) {\n    const computedTime = this.toSeconds(when);\n    const computedDuration = this.toSeconds(duration);\n    const startTicks = this.getTicksAtTime(computedTime);\n    const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n    return endTicks - startTicks;\n  }\n  /**\n   * Convert from the type when the unit value is BPM\n   */\n\n\n  _fromType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return 1 / (60 / val / this.multiplier);\n    } else {\n      return super._fromType(val);\n    }\n  }\n  /**\n   * Special case of type conversion where the units === \"bpm\"\n   */\n\n\n  _toType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return val / this.multiplier * 60;\n    } else {\n      return super._toType(val);\n    }\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n\n\n  get multiplier() {\n    return this._multiplier;\n  }\n\n  set multiplier(m) {\n    // get and reset the current value with the new multiplier\n    // might be necessary to clear all the previous values\n    const currentVal = this.value;\n    this._multiplier = m;\n    this.cancelScheduledValues(0);\n    this.setValueAtTime(currentVal, 0);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Param","optionsFromArguments","Timeline","isUndef","TickParam","constructor","getDefaults","arguments","Infinity","options","_multiplier","multiplier","_events","cancel","add","ticks","time","type","value","_fromType","setValueAtTime","Object","assign","units","setTargetAtTime","constant","toSeconds","setRampPoint","computedValue","prevEvent","get","segments","Math","round","max","i","segTime","rampVal","_exponentialApproach","linearRampToValueAtTime","_toType","computedTime","event","previousEvent","ticksUntilTime","_getTicksUntilEvent","exponentialRampToValueAtTime","computedVal","segmentDur","_exponentialInterpolate","val0","getValueAtTime","val1","onTheLineEvent","sampleTime","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","before","after","getAfter","delta","k","sqrt","pow","sol1","sol2","_initialValue","ticksToTime","when","timeToTicks","duration","computedDuration","startTicks","endTicks","val","m","currentVal","cancelScheduledValues"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/TickParam.ts"],"sourcesContent":["import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}