{"ast":null,"code":"import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope } from \"../component/envelope/FrequencyEnvelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class MonoSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n    this.name = \"MonoSynth\";\n    const options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.filter = new Filter(Object.assign(options.filter, {\n      context: this.context\n    }));\n    this.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, {\n      context: this.context\n    }));\n    this.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, {\n      context: this.context\n    })); // connect the oscillators to the output\n\n    this.oscillator.chain(this.filter, this.envelope, this.output); // connect the filter envelope\n\n    this.filterEnvelope.connect(this.filter.frequency);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.9\n      }),\n      filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        Q: 1,\n        rolloff: -12,\n        type: \"lowpass\"\n      }),\n      filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.6,\n        baseFrequency: 200,\n        decay: 0.2,\n        exponent: 2,\n        octaves: 3,\n        release: 2,\n        sustain: 0.5\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {\n        type: \"sawtooth\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time) {\n    let velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.envelope.triggerAttack(time, velocity);\n    this.filterEnvelope.triggerAttack(time);\n    this.oscillator.start(time);\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.filterEnvelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    this.filterEnvelope.dispose();\n    this.filter.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,iBAAT,QAAkC,yCAAlC;AACA,SAASC,QAAT,QAA0C,gCAA1C;AACA,SAASC,MAAT,QAAsC,4BAAtC;AACA,SAASC,cAAT,EAAyBC,oBAAzB,QAAqD,uBAArD;AACA,SAASC,QAAT,QAA2C,wBAA3C;AACA,SAASC,UAAT,QAA8C,0BAA9C;AACA,SAASC,cAAT,QAA+B,qCAA/B;AACA,SAASC,MAAT,QAAuB,kBAAvB;AACA,SAASC,iBAAT,QAA4D,yCAA5D;AAGA,SAASC,aAAT,QAAoD,+BAApD;AAUA;;;;;;;;;;;;;;;;;;AAiBA,OAAM,MAAOC,SAAP,SAAyBL,UAAzB,CAAqD;EAmC1DM;IACC,MAAMR,oBAAoB,CAACO,SAAS,CAACE,WAAV,EAAD,EAA0BC,SAA1B,CAA1B;IAlCQ,YAAO,WAAP;IAmCR,MAAMC,OAAO,GAAGX,oBAAoB,CAACO,SAAS,CAACE,WAAV,EAAD,EAA0BC,SAA1B,CAApC;IAEA,KAAKE,UAAL,GAAkB,IAAIT,cAAJ,CAAmBU,MAAM,CAACC,MAAP,CAAcH,OAAO,CAACC,UAAtB,EAAkC;MACtEG,OAAO,EAAE,KAAKA,OADwD;MAEtEC,MAAM,EAAEL,OAAO,CAACK,MAFsD;MAGtEC,MAAM,EAAE,MAAM,KAAKC,SAAL,CAAe,IAAf;IAHwD,CAAlC,CAAnB,CAAlB;IAKA,KAAKC,SAAL,GAAiB,KAAKP,UAAL,CAAgBO,SAAjC;IACA,KAAKH,MAAL,GAAc,KAAKJ,UAAL,CAAgBI,MAA9B;IACA,KAAKI,MAAL,GAAc,IAAItB,MAAJ,CAAWe,MAAM,CAACC,MAAP,CAAcH,OAAO,CAACS,MAAtB,EAA8B;MAAEL,OAAO,EAAE,KAAKA;IAAhB,CAA9B,CAAX,CAAd;IACA,KAAKM,cAAL,GAAsB,IAAIhB,iBAAJ,CAAsBQ,MAAM,CAACC,MAAP,CAAcH,OAAO,CAACU,cAAtB,EAAsC;MAAEN,OAAO,EAAE,KAAKA;IAAhB,CAAtC,CAAtB,CAAtB;IACA,KAAKO,QAAL,GAAgB,IAAI1B,iBAAJ,CAAsBiB,MAAM,CAACC,MAAP,CAAcH,OAAO,CAACW,QAAtB,EAAgC;MAAEP,OAAO,EAAE,KAAKA;IAAhB,CAAhC,CAAtB,CAAhB,CAbD,CAeC;;IACA,KAAKH,UAAL,CAAgBW,KAAhB,CAAsB,KAAKH,MAA3B,EAAmC,KAAKE,QAAxC,EAAkD,KAAKE,MAAvD,EAhBD,CAkBC;;IACA,KAAKH,cAAL,CAAoBI,OAApB,CAA4B,KAAKL,MAAL,CAAYD,SAAxC;IAEAlB,QAAQ,CAAC,IAAD,EAAO,CAAC,YAAD,EAAe,WAAf,EAA4B,QAA5B,EAAsC,QAAtC,EAAgD,gBAAhD,EAAkE,UAAlE,CAAP,CAAR;EACA;;EAEiB,OAAXQ,WAAW;IACjB,OAAOI,MAAM,CAACC,MAAP,CAAcZ,UAAU,CAACO,WAAX,EAAd,EAAwC;MAC9Ca,QAAQ,EAAET,MAAM,CAACC,MAAP,CACTf,cAAc,CAACF,QAAQ,CAACY,WAAT,EAAD,EAAyBI,MAAM,CAACa,IAAP,CAAYpB,aAAa,CAACG,WAAd,EAAZ,CAAzB,CADL,EAET;QACCkB,MAAM,EAAE,KADT;QAECC,KAAK,EAAE,GAFR;QAGCC,OAAO,EAAE,CAHV;QAICC,OAAO,EAAE;MAJV,CAFS,CADoC;MAU9CV,MAAM,EAAEP,MAAM,CAACC,MAAP,CACPf,cAAc,CAACD,MAAM,CAACW,WAAP,EAAD,EAAuBI,MAAM,CAACa,IAAP,CAAYpB,aAAa,CAACG,WAAd,EAAZ,CAAvB,CADP,EAEP;QACCsB,CAAC,EAAE,CADJ;QAECC,OAAO,EAAE,CAAC,EAFX;QAGCC,IAAI,EAAE;MAHP,CAFO,CAVsC;MAkB9CZ,cAAc,EAAER,MAAM,CAACC,MAAP,CACff,cAAc,CAACM,iBAAiB,CAACI,WAAlB,EAAD,EAAkCI,MAAM,CAACa,IAAP,CAAYpB,aAAa,CAACG,WAAd,EAAZ,CAAlC,CADC,EAEf;QACCkB,MAAM,EAAE,GADT;QAECO,aAAa,EAAE,GAFhB;QAGCN,KAAK,EAAE,GAHR;QAICO,QAAQ,EAAE,CAJX;QAKCC,OAAO,EAAE,CALV;QAMCP,OAAO,EAAE,CANV;QAOCC,OAAO,EAAE;MAPV,CAFe,CAlB8B;MA8B9ClB,UAAU,EAAEC,MAAM,CAACC,MAAP,CACXf,cAAc,CAACI,cAAc,CAACM,WAAf,EAAD,EAA+BI,MAAM,CAACa,IAAP,CAAYtB,MAAM,CAACK,WAAP,EAAZ,CAA/B,CADH,EAEX;QACCwB,IAAI,EAAE;MADP,CAFW;IA9BkC,CAAxC,CAAP;EAqCA;EAED;;;;;;;EAKUI,sBAAsB,CAACC,IAAD,EAA4B;IAAA,IAAZC,QAAY,uEAAD,CAAC;IAC3D,KAAKjB,QAAL,CAAckB,aAAd,CAA4BF,IAA5B,EAAkCC,QAAlC;IACA,KAAKlB,cAAL,CAAoBmB,aAApB,CAAkCF,IAAlC;IACA,KAAK1B,UAAL,CAAgB6B,KAAhB,CAAsBH,IAAtB;;IACA,IAAI,KAAKhB,QAAL,CAAcQ,OAAd,KAA0B,CAA9B,EAAiC;MAChC,MAAMY,cAAc,GAAG,KAAKC,SAAL,CAAe,KAAKrB,QAAL,CAAcK,MAA7B,CAAvB;MACA,MAAMiB,aAAa,GAAG,KAAKD,SAAL,CAAe,KAAKrB,QAAL,CAAcM,KAA7B,CAAtB;MACA,KAAKhB,UAAL,CAAgBiC,IAAhB,CAAqBP,IAAI,GAAGI,cAAP,GAAwBE,aAA7C;IACA;EACD;EAED;;;;;;EAIUE,uBAAuB,CAACR,IAAD,EAAc;IAC9C,KAAKhB,QAAL,CAAcyB,cAAd,CAA6BT,IAA7B;IACA,KAAKjB,cAAL,CAAoB0B,cAApB,CAAmCT,IAAnC;IACA,KAAK1B,UAAL,CAAgBiC,IAAhB,CAAqBP,IAAI,GAAG,KAAKK,SAAL,CAAe,KAAKrB,QAAL,CAAcO,OAA7B,CAA5B;EACA;;EAEDmB,cAAc,CAACV,IAAD,EAAW;IACxBA,IAAI,GAAG,KAAKK,SAAL,CAAeL,IAAf,CAAP;IACA,OAAO,KAAKhB,QAAL,CAAc2B,cAAd,CAA6BX,IAA7B,CAAP;EACA;;EAEDY,OAAO;IACN,MAAMA,OAAN;IACA,KAAKtC,UAAL,CAAgBsC,OAAhB;IACA,KAAK5B,QAAL,CAAc4B,OAAd;IACA,KAAK7B,cAAL,CAAoB6B,OAApB;IACA,KAAK9B,MAAL,CAAY8B,OAAZ;IACA,OAAO,IAAP;EACA;;AAzIyD","names":["AmplitudeEnvelope","Envelope","Filter","omitFromObject","optionsFromArguments","readOnly","Monophonic","OmniOscillator","Source","FrequencyEnvelope","ToneAudioNode","MonoSynth","constructor","getDefaults","arguments","options","oscillator","Object","assign","context","detune","onstop","onsilence","frequency","filter","filterEnvelope","envelope","chain","output","connect","keys","attack","decay","release","sustain","Q","rolloff","type","baseFrequency","exponent","octaves","_triggerEnvelopeAttack","time","velocity","triggerAttack","start","computedAttack","toSeconds","computedDecay","stop","_triggerEnvelopeRelease","triggerRelease","getLevelAtTime","getValueAtTime","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/instrument/MonoSynth.ts"],"sourcesContent":["import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic, MonophonicOptions } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope, FrequencyEnvelopeOptions } from \"../component/envelope/FrequencyEnvelope\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\n\nexport interface MonoSynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilterEnvelope: Omit<FrequencyEnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilter: Omit<FilterOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic<MonoSynthOptions> {\n\n\treadonly name = \"MonoSynth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The filter.\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The filter envelope.\n\t */\n\treadonly filterEnvelope: FrequencyEnvelope;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<MonoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}));\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\t\tthis.filter = new Filter(Object.assign(options.filter, { context: this.context }));\n\t\tthis.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.filter, this.envelope, this.output);\n\n\t\t// connect the filter envelope\n\t\tthis.filterEnvelope.connect(this.filter.frequency);\n\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MonoSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.9,\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilter: Object.assign(\n\t\t\t\tomitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tQ: 1,\n\t\t\t\t\trolloff: -12,\n\t\t\t\t\ttype: \"lowpass\",\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilterEnvelope: Object.assign(\n\t\t\t\tomitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.6,\n\t\t\t\t\tbaseFrequency: 200,\n\t\t\t\t\tdecay: 0.2,\n\t\t\t\t\texponent: 2,\n\t\t\t\t\toctaves: 3,\n\t\t\t\t\trelease: 2,\n\t\t\t\t\tsustain: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sawtooth\",\n\t\t\t\t},\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity = 1): void {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.filterEnvelope.triggerAttack(time);\n\t\tthis.oscillator.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.filterEnvelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis.filterEnvelope.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}