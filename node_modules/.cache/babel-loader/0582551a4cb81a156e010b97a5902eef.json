{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\n\nexport class TimeBaseClass extends Tone {\n  /**\n   * @param context The context associated with the time value. Used to compute\n   * Transport and context-relative timing.\n   * @param  value  The time value as a number, string or object\n   * @param  units  Unit values\n   */\n  constructor(context, value, units) {\n    super();\n    /**\n     * The default units\n     */\n\n    this.defaultUnits = \"s\";\n    this._val = value;\n    this._units = units;\n    this.context = context;\n    this._expressions = this._getExpressions();\n  }\n  /**\n   * All of the time encoding expressions\n   */\n\n\n  _getExpressions() {\n    return {\n      hz: {\n        method: value => {\n          return this._frequencyToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)hz$/i\n      },\n      i: {\n        method: value => {\n          return this._ticksToUnits(parseInt(value, 10));\n        },\n        regexp: /^(\\d+)i$/i\n      },\n      m: {\n        method: value => {\n          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n        },\n        regexp: /^(\\d+)m$/i\n      },\n      n: {\n        method: (value, dot) => {\n          const numericValue = parseInt(value, 10);\n          const scalar = dot === \".\" ? 1.5 : 1;\n\n          if (numericValue === 1) {\n            return this._beatsToUnits(this._getTimeSignature()) * scalar;\n          } else {\n            return this._beatsToUnits(4 / numericValue) * scalar;\n          }\n        },\n        regexp: /^(\\d+)n(\\.?)$/i\n      },\n      number: {\n        method: value => {\n          return this._expressions[this.defaultUnits].method.call(this, value);\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)$/\n      },\n      s: {\n        method: value => {\n          return this._secondsToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)s$/\n      },\n      samples: {\n        method: value => {\n          return parseInt(value, 10) / this.context.sampleRate;\n        },\n        regexp: /^(\\d+)samples$/\n      },\n      t: {\n        method: value => {\n          const numericValue = parseInt(value, 10);\n          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n        },\n        regexp: /^(\\d+)t$/i\n      },\n      tr: {\n        method: (m, q, s) => {\n          let total = 0;\n\n          if (m && m !== \"0\") {\n            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total += this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total += this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/\n      }\n    };\n  } //-------------------------------------\n  // \tVALUE OF\n  //-------------------------------------\n\n  /**\n   * Evaluate the time value. Returns the time in seconds.\n   */\n\n\n  valueOf() {\n    if (this._val instanceof TimeBaseClass) {\n      this.fromType(this._val);\n    }\n\n    if (isUndef(this._val)) {\n      return this._noArg();\n    } else if (isString(this._val) && isUndef(this._units)) {\n      for (const units in this._expressions) {\n        if (this._expressions[units].regexp.test(this._val.trim())) {\n          this._units = units;\n          break;\n        }\n      }\n    } else if (isObject(this._val)) {\n      let total = 0;\n\n      for (const typeName in this._val) {\n        if (isDefined(this._val[typeName])) {\n          const quantity = this._val[typeName]; // @ts-ignore\n\n          const time = new this.constructor(this.context, typeName).valueOf() * quantity;\n          total += time;\n        }\n      }\n\n      return total;\n    }\n\n    if (isDefined(this._units)) {\n      const expr = this._expressions[this._units];\n\n      const matching = this._val.toString().trim().match(expr.regexp);\n\n      if (matching) {\n        return expr.method.apply(this, matching.slice(1));\n      } else {\n        return expr.method.call(this, this._val);\n      }\n    } else if (isString(this._val)) {\n      return parseFloat(this._val);\n    } else {\n      return this._val;\n    }\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return 1 / freq;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 60 / this._getBpm() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return seconds;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks * this._beatsToUnits(1) / this._getPPQ();\n  }\n  /**\n   * With no arguments, return 'now'\n   */\n\n\n  _noArg() {\n    return this._now();\n  } //-------------------------------------\n  // \tTEMPO CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the bpm\n   */\n\n\n  _getBpm() {\n    return this.context.transport.bpm.value;\n  }\n  /**\n   * Return the timeSignature\n   */\n\n\n  _getTimeSignature() {\n    return this.context.transport.timeSignature;\n  }\n  /**\n   * Return the PPQ or 192 if Transport is not available\n   */\n\n\n  _getPPQ() {\n    return this.context.transport.PPQ;\n  } //-------------------------------------\n  // \tCONVERSION INTERFACE\n  //-------------------------------------\n\n  /**\n   * Coerce a time type into this units type.\n   * @param type Any time type units\n   */\n\n\n  fromType(type) {\n    this._units = undefined;\n\n    switch (this.defaultUnits) {\n      case \"s\":\n        this._val = type.toSeconds();\n        break;\n\n      case \"i\":\n        this._val = type.toTicks();\n        break;\n\n      case \"hz\":\n        this._val = type.toFrequency();\n        break;\n\n      case \"midi\":\n        this._val = type.toMidi();\n        break;\n    }\n\n    return this;\n  }\n  /**\n   * Return the value in hertz\n   */\n\n\n  toFrequency() {\n    return 1 / this.toSeconds();\n  }\n  /**\n   * Return the time in samples\n   */\n\n\n  toSamples() {\n    return this.toSeconds() * this.context.sampleRate;\n  }\n  /**\n   * Return the time in milliseconds.\n   */\n\n\n  toMilliseconds() {\n    return this.toSeconds() * 1000;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Tone","isDefined","isObject","isString","isUndef","TimeBaseClass","constructor","context","value","units","_val","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","i","_ticksToUnits","parseInt","m","_beatsToUnits","_getTimeSignature","n","dot","numericValue","scalar","number","defaultUnits","call","s","_secondsToUnits","samples","sampleRate","t","Math","floor","tr","q","total","valueOf","fromType","_noArg","test","trim","typeName","quantity","time","expr","matching","toString","match","apply","slice","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","type","undefined","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/type/TimeBase.ts"],"sourcesContent":["import { BaseContext } from \"../context/BaseContext\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: BaseContext;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: BaseContext, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}