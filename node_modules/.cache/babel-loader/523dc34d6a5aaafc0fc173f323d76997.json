{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\n\nexport class Analyser extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n    this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n\n    this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n\n    this._buffers = [];\n    const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    this.input = this.output = this._gain = new Gain({\n      context: this.context\n    });\n    this._split = new Split({\n      context: this.context,\n      channels: options.channels\n    });\n    this.input.connect(this._split);\n    assertRange(options.channels, 1); // create the analysers\n\n    for (let channel = 0; channel < options.channels; channel++) {\n      this._analysers[channel] = this.context.createAnalyser();\n\n      this._split.connect(this._analysers[channel], channel, 0);\n    } // set the values initially\n\n\n    this.size = options.size;\n    this.type = options.type;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  }\n  /**\n   * Run the analysis given the current settings. If [[channels]] = 1,\n   * it will return a Float32Array. If [[channels]] > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n\n\n  getValue() {\n    this._analysers.forEach((analyser, index) => {\n      const buffer = this._buffers[index];\n\n      if (this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   */\n\n\n  get size() {\n    return this._analysers[0].frequencyBinCount;\n  }\n\n  set size(size) {\n    this._analysers.forEach((analyser, index) => {\n      analyser.fftSize = size * 2;\n      this._buffers[index] = new Float32Array(size);\n    });\n  }\n  /**\n   * The number of channels the analyser does the analysis on. Channel\n   * separation is done using [[Split]]\n   */\n\n\n  get channels() {\n    return this._analysers.length;\n  }\n  /**\n   * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n    this._type = type;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analysers[0].smoothingTimeConstant;\n  }\n\n  set smoothing(val) {\n    this._analysers.forEach(a => a.smoothingTimeConstant = val);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._analysers.forEach(a => a.disconnect());\n\n    this._split.dispose();\n\n    this._gain.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAAgCA,aAAhC,QAA2E,kCAA3E;AAEA,SAASC,oBAAT,QAAqC,0BAArC;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,IAAT,QAAqB,yBAArB;AACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,uBAApC;AAWA;;;;;;AAKA,OAAM,MAAOC,QAAP,SAAwBN,aAAxB,CAAsD;EAsC3DO;IACC,MAAMN,oBAAoB,CAACK,QAAQ,CAACE,WAAT,EAAD,EAAyBC,SAAzB,EAAoC,CAAC,MAAD,EAAS,MAAT,CAApC,CAA1B;IArCQ,YAAe,UAAf;IAKT;;;;IAGQ,kBAA6B,EAA7B;IAiBR;;;;IAGQ,gBAA2B,EAA3B;IAUP,MAAMC,OAAO,GAAGT,oBAAoB,CAACK,QAAQ,CAACE,WAAT,EAAD,EAAyBC,SAAzB,EAAoC,CAAC,MAAD,EAAS,MAAT,CAApC,CAApC;IAEA,KAAKE,KAAL,GAAa,KAAKC,MAAL,GAAc,KAAKC,KAAL,GAAa,IAAIV,IAAJ,CAAS;MAAEW,OAAO,EAAE,KAAKA;IAAhB,CAAT,CAAxC;IACA,KAAKC,MAAL,GAAc,IAAIb,KAAJ,CAAU;MACvBY,OAAO,EAAE,KAAKA,OADS;MAEvBE,QAAQ,EAAEN,OAAO,CAACM;IAFK,CAAV,CAAd;IAIA,KAAKL,KAAL,CAAWM,OAAX,CAAmB,KAAKF,MAAxB;IAEAV,WAAW,CAACK,OAAO,CAACM,QAAT,EAAmB,CAAnB,CAAX,CAXD,CAaC;;IACA,KAAK,IAAIE,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGR,OAAO,CAACM,QAAxC,EAAkDE,OAAO,EAAzD,EAA6D;MAC5D,KAAKC,UAAL,CAAgBD,OAAhB,IAA2B,KAAKJ,OAAL,CAAaM,cAAb,EAA3B;;MACA,KAAKL,MAAL,CAAYE,OAAZ,CAAoB,KAAKE,UAAL,CAAgBD,OAAhB,CAApB,EAA8CA,OAA9C,EAAuD,CAAvD;IACA,CAjBF,CAmBC;;;IACA,KAAKG,IAAL,GAAYX,OAAO,CAACW,IAApB;IACA,KAAKC,IAAL,GAAYZ,OAAO,CAACY,IAApB;EACA;;EAEiB,OAAXd,WAAW;IACjB,OAAOe,MAAM,CAACC,MAAP,CAAcxB,aAAa,CAACQ,WAAd,EAAd,EAA2C;MACjDa,IAAI,EAAE,IAD2C;MAEjDI,SAAS,EAAE,GAFsC;MAGjDH,IAAI,EAAE,KAH2C;MAIjDN,QAAQ,EAAE;IAJuC,CAA3C,CAAP;EAMA;EAED;;;;;;;;EAMAU,QAAQ;IACP,KAAKP,UAAL,CAAgBQ,OAAhB,CAAwB,CAACC,QAAD,EAAWC,KAAX,KAAoB;MAC3C,MAAMC,MAAM,GAAG,KAAKC,QAAL,CAAcF,KAAd,CAAf;;MACA,IAAI,KAAKG,KAAL,KAAe,KAAnB,EAA0B;QACzBJ,QAAQ,CAACK,qBAAT,CAA+BH,MAA/B;MACA,CAFD,MAEO,IAAI,KAAKE,KAAL,KAAe,UAAnB,EAA+B;QACrCJ,QAAQ,CAACM,sBAAT,CAAgCJ,MAAhC;MACA;IACD,CAPD;;IAQA,IAAI,KAAKd,QAAL,KAAkB,CAAtB,EAAyB;MACxB,OAAO,KAAKe,QAAL,CAAc,CAAd,CAAP;IACA,CAFD,MAEO;MACN,OAAO,KAAKA,QAAZ;IACA;EACD;EAED;;;;;EAGQ,IAAJV,IAAI;IACP,OAAO,KAAKF,UAAL,CAAgB,CAAhB,EAAmBgB,iBAA1B;EACA;;EACO,IAAJd,IAAI,CAACA,IAAD,EAAiB;IACxB,KAAKF,UAAL,CAAgBQ,OAAhB,CAAwB,CAACC,QAAD,EAAWC,KAAX,KAAoB;MAC3CD,QAAQ,CAACQ,OAAT,GAAmBf,IAAI,GAAG,CAA1B;MACA,KAAKU,QAAL,CAAcF,KAAd,IAAuB,IAAIQ,YAAJ,CAAiBhB,IAAjB,CAAvB;IACA,CAHD;EAIA;EAED;;;;;;EAIY,IAARL,QAAQ;IACX,OAAO,KAAKG,UAAL,CAAgBmB,MAAvB;EACA;EAED;;;;;EAGQ,IAAJhB,IAAI;IACP,OAAO,KAAKU,KAAZ;EACA;;EACO,IAAJV,IAAI,CAACA,IAAD,EAAmB;IAC1BlB,MAAM,CAACkB,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,KAAjC,EAAwC,2BAA2BA,IAAI,EAAvE,CAAN;IACA,KAAKU,KAAL,GAAaV,IAAb;EACA;EAED;;;;;EAGa,IAATG,SAAS;IACZ,OAAO,KAAKN,UAAL,CAAgB,CAAhB,EAAmBoB,qBAA1B;EACA;;EACY,IAATd,SAAS,CAACe,GAAD,EAAiB;IAC7B,KAAKrB,UAAL,CAAgBQ,OAAhB,CAAwBc,CAAC,IAAIA,CAAC,CAACF,qBAAF,GAA0BC,GAAvD;EACA;EAED;;;;;EAGAE,OAAO;IACN,MAAMA,OAAN;;IACA,KAAKvB,UAAL,CAAgBQ,OAAhB,CAAwBc,CAAC,IAAIA,CAAC,CAACE,UAAF,EAA7B;;IACA,KAAK5B,MAAL,CAAY2B,OAAZ;;IACA,KAAK7B,KAAL,CAAW6B,OAAX;;IACA,OAAO,IAAP;EACA;;AAhJ0D","names":["ToneAudioNode","optionsFromArguments","Split","Gain","assert","assertRange","Analyser","constructor","getDefaults","arguments","options","input","output","_gain","context","_split","channels","connect","channel","_analysers","createAnalyser","size","type","Object","assign","smoothing","getValue","forEach","analyser","index","buffer","_buffers","_type","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","fftSize","Float32Array","length","smoothingTimeConstant","val","a","dispose","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/analysis/Analyser.ts"],"sourcesContent":["import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n\tchannels: number;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analysers: AnalyserNode[] = [];\n\n\t/**\n\t * Input and output are a gain node\n\t */\n\tprivate _gain: Gain;\n\n\t/**\n\t * The channel splitter node\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffers: Float32Array[] = [];\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\n\t\tthis.input = this.output = this._gain = new Gain({ context: this.context });\n\t\tthis._split = new Split({\n\t\t\tcontext: this.context,\n\t\t\tchannels: options.channels,\n\t\t});\n\t\tthis.input.connect(this._split);\n\t\t\n\t\tassertRange(options.channels, 1);\n\t\t\n\t\t// create the analysers\n\t\tfor (let channel = 0; channel < options.channels; channel++) {\n\t\t\tthis._analysers[channel] = this.context.createAnalyser();\n\t\t\tthis._split.connect(this._analysers[channel], channel, 0);\n\t\t}\n\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings. If [[channels]] = 1,\n\t * it will return a Float32Array. If [[channels]] > 1, it will\n\t * return an array of Float32Arrays where each index in the array\n\t * represents the analysis done on a channel.\n\t */\n\tgetValue(): Float32Array | Float32Array[] {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tconst buffer = this._buffers[index];\n\t\t\tif (this._type === \"fft\") {\n\t\t\t\tanalyser.getFloatFrequencyData(buffer);\n\t\t\t} else if (this._type === \"waveform\") {\n\t\t\t\tanalyser.getFloatTimeDomainData(buffer);\n\t\t\t}\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn this._buffers[0];\n\t\t} else {\n\t\t\treturn this._buffers;\n\t\t}\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analysers[0].frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tanalyser.fftSize = size * 2;\n\t\t\tthis._buffers[index] = new Float32Array(size);\n\t\t});\n\t}\n\n\t/**\n\t * The number of channels the analyser does the analysis on. Channel\n\t * separation is done using [[Split]]\n\t */\n\tget channels(): number {\n\t\treturn this._analysers.length;\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tassert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analysers[0].smoothingTimeConstant;\n\t}\n\tset smoothing(val: NormalRange) {\n\t\tthis._analysers.forEach(a => a.smoothingTimeConstant = val);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analysers.forEach(a => a.disconnect());\n\t\tthis._split.dispose();\n\t\tthis._gain.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}