{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\n\nexport class Recorder extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Recorder.getDefaults(), arguments));\n    this.name = \"Recorder\";\n    const options = optionsFromArguments(Recorder.getDefaults(), arguments);\n    this.input = new Gain({\n      context: this.context\n    });\n    assert(Recorder.supported, \"Media Recorder API is not available\");\n    this._stream = this.context.createMediaStreamDestination();\n    this.input.connect(this._stream);\n    this._recorder = new MediaRecorder(this._stream.stream, {\n      mimeType: options.mimeType\n    });\n  }\n\n  static getDefaults() {\n    return ToneAudioNode.getDefaults();\n  }\n  /**\n   * The mime type is the format that the audio is encoded in. For Chrome\n   * that is typically webm encoded as \"vorbis\".\n   */\n\n\n  get mimeType() {\n    return this._recorder.mimeType;\n  }\n  /**\n   * Test if your platform supports the Media Recorder API. If it's not available,\n   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n   */\n\n\n  static get supported() {\n    return theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n  }\n  /**\n   * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n   */\n\n\n  get state() {\n    if (this._recorder.state === \"inactive\") {\n      return \"stopped\";\n    } else if (this._recorder.state === \"paused\") {\n      return \"paused\";\n    } else {\n      return \"started\";\n    }\n  }\n  /**\n   * Start the Recorder. Returns a promise which resolves\n   * when the recorder has started.\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"started\", \"Recorder is already started\");\n      const startPromise = new Promise(done => {\n        const handleStart = () => {\n          this._recorder.removeEventListener(\"start\", handleStart, false);\n\n          done();\n        };\n\n        this._recorder.addEventListener(\"start\", handleStart, false);\n      });\n\n      this._recorder.start();\n\n      return yield startPromise;\n    });\n  }\n  /**\n   * Stop the recorder. Returns a promise with the recorded content until this point\n   * encoded as [[mimeType]]\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"stopped\", \"Recorder is not started\");\n      const dataPromise = new Promise(done => {\n        const handleData = e => {\n          this._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n          done(e.data);\n        };\n\n        this._recorder.addEventListener(\"dataavailable\", handleData, false);\n      });\n\n      this._recorder.stop();\n\n      return yield dataPromise;\n    });\n  }\n  /**\n   * Pause the recorder\n   */\n\n\n  pause() {\n    assert(this.state === \"started\", \"Recorder must be started\");\n\n    this._recorder.pause();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n\n    this._stream.disconnect();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ToneAudioNode","Gain","assert","theWindow","optionsFromArguments","Recorder","constructor","getDefaults","arguments","options","input","context","supported","_stream","createMediaStreamDestination","connect","_recorder","MediaRecorder","stream","mimeType","Reflect","has","state","start","startPromise","Promise","done","handleStart","removeEventListener","addEventListener","stop","dataPromise","handleData","e","data","pause","dispose","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/channel/Recorder.ts"],"sourcesContent":["import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\n\nexport interface RecorderOptions extends ToneAudioNodeOptions {\n\tmimeType?: string;\n}\n\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox. \n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill]. \n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\nexport class Recorder extends ToneAudioNode<RecorderOptions> {\n\n\treadonly name = \"Recorder\";\n\n\t/**\n\t * Recorder uses the Media Recorder API\n\t */\n\tprivate _recorder: MediaRecorder;\n\n\t/**\n\t * MediaRecorder requires \n\t */\n\tprivate _stream: MediaStreamAudioDestinationNode;\n\n\treadonly input: Gain;\n\treadonly output: undefined;\n\n\tconstructor(options?: Partial<RecorderOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Recorder.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Recorder.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({\n\t\t\tcontext: this.context\n\t\t});\n\n\t\tassert(Recorder.supported, \"Media Recorder API is not available\");\n\n\t\tthis._stream = this.context.createMediaStreamDestination();\n\t\tthis.input.connect(this._stream);\n\t\tthis._recorder = new MediaRecorder(this._stream.stream, {\n\t\t\tmimeType: options.mimeType\n\t\t});\n\t}\n\n\tstatic getDefaults(): RecorderOptions {\n\t\treturn ToneAudioNode.getDefaults();\n\t}\n\n\t/**\n\t * The mime type is the format that the audio is encoded in. For Chrome \n\t * that is typically webm encoded as \"vorbis\". \n\t */\n\tget mimeType(): string {\n\t\treturn this._recorder.mimeType;\n\t}\n\n\t/**\n\t * Test if your platform supports the Media Recorder API. If it's not available, \n\t * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n\t */\n\tstatic get supported(): boolean {\n\t\treturn theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n\t}\n\n\t/**\n\t * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._recorder.state === \"inactive\") {\n\t\t\treturn \"stopped\";\n\t\t} else if (this._recorder.state === \"paused\") {\n\t\t\treturn \"paused\";\n\t\t} else {\n\t\t\treturn \"started\";\n\t\t}\n\t}\n\n\t/**\n\t * Start the Recorder. Returns a promise which resolves\n\t * when the recorder has started.\n\t */\n\tasync start() {\n\t\tassert(this.state !== \"started\", \"Recorder is already started\");\n\t\tconst startPromise = new Promise(done => {\n\t\t\tconst handleStart = () => {\n\t\t\t\tthis._recorder.removeEventListener(\"start\", handleStart, false);\n\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"start\", handleStart, false);\n\t\t});\n\n\t\tthis._recorder.start();\n\t\treturn await startPromise;\n\t}\n\n\t/**\n\t * Stop the recorder. Returns a promise with the recorded content until this point\n\t * encoded as [[mimeType]]\n\t */\n\tasync stop(): Promise<Blob> {\n\t\tassert(this.state !== \"stopped\", \"Recorder is not started\");\n\t\tconst dataPromise: Promise<Blob> = new Promise(done => {\n\t\t\tconst handleData = (e: BlobEvent) => {\n\t\t\t\tthis._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n\t\t\t\tdone(e.data);\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"dataavailable\", handleData, false);\n\t\t});\n\t\tthis._recorder.stop();\n\t\treturn await dataPromise;\n\t}\n\n\t/**\n\t * Pause the recorder\n\t */\n\tpause(): this {\n\t\tassert(this.state === \"started\", \"Recorder must be started\");\n\t\tthis._recorder.pause();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._stream.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}