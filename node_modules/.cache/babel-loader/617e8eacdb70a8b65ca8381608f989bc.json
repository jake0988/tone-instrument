{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport class Reverb extends Effect {\n  constructor() {\n    super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    this.ready = Promise.resolve();\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n\n\n  get decay() {\n    return this._decay;\n  }\n\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n\n\n  get preDelay() {\n    return this._preDelay;\n  }\n\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n\n\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0); // predelay\n\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n      yield previousReady; // set the buffer\n\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._convolver.disconnect();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Merge","Gain","optionsFromArguments","Noise","Effect","OfflineContext","noOp","assertRange","Reverb","constructor","getDefaults","arguments","context","createConvolver","Promise","resolve","options","_decay","decay","_preDelay","preDelay","generate","connectEffect","_convolver","Object","assign","time","toSeconds","previousReady","ready","sampleRate","noiseL","noiseR","merge","connect","gainNode","toDestination","start","gain","setValueAtTime","exponentialApproachValueAtTime","renderPromise","render","then","buffer","get","dispose","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/effect/Reverb.ts"],"sourcesContent":["import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound. \n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n\t * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n\t * before the IR is generated with the latest values. \n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n\t\t\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\t\t\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}