{"ast":null,"code":"import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\n\nexport class ToneOscillatorNode extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"ToneOscillatorNode\";\n    /**\n     * The oscillator\n     */\n\n    this._oscillator = this.context.createOscillator();\n    this._internalChannels = [this._oscillator];\n    const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    connect(this._oscillator, this._gainNode);\n    this.type = options.type;\n    this.frequency = new Param({\n      context: this.context,\n      param: this._oscillator.frequency,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Param({\n      context: this.context,\n      param: this._oscillator.detune,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      type: \"sine\"\n    });\n  }\n  /**\n   * Start the oscillator node at the given time\n   * @param  time When to start the oscillator\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._oscillator.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._oscillator.stop(time);\n  }\n  /**\n   * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n   */\n\n\n  setPeriodicWave(periodicWave) {\n    this._oscillator.setPeriodicWave(periodicWave);\n\n    return this;\n  }\n  /**\n   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._oscillator.disconnect();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,kCAAxB;AACA,SAASC,KAAT,QAAsB,0BAAtB;AAEA,SAASC,oBAAT,QAAqC,0BAArC;AACA,SAASC,aAAT,QAAoD,kBAApD;AACA,SAASC,QAAT,QAAyB,2BAAzB;AAQA;;;;;;;AAMA,OAAM,MAAOC,kBAAP,SAAkCF,aAAlC,CAA0E;EA6B/EG;IAEC,MAAMJ,oBAAoB,CAACG,kBAAkB,CAACE,WAAnB,EAAD,EAAmCC,SAAnC,EAA8C,CAAC,WAAD,EAAc,MAAd,CAA9C,CAA1B;IA7BQ,YAAe,oBAAf;IAET;;;;IAGQ,mBAAc,KAAKC,OAAL,CAAaC,gBAAb,EAAd;IACE,yBAAoB,CAAC,KAAKC,WAAN,CAApB;IAwBT,MAAMC,OAAO,GAAGV,oBAAoB,CAACG,kBAAkB,CAACE,WAAnB,EAAD,EAAmCC,SAAnC,EAA8C,CAAC,WAAD,EAAc,MAAd,CAA9C,CAApC;IAEAR,OAAO,CAAC,KAAKW,WAAN,EAAmB,KAAKE,SAAxB,CAAP;IAEA,KAAKC,IAAL,GAAYF,OAAO,CAACE,IAApB;IAEA,KAAKC,SAAL,GAAiB,IAAId,KAAJ,CAAU;MAC1BQ,OAAO,EAAE,KAAKA,OADY;MAE1BO,KAAK,EAAE,KAAKL,WAAL,CAAiBI,SAFE;MAG1BE,KAAK,EAAE,WAHmB;MAI1BC,KAAK,EAAEN,OAAO,CAACG;IAJW,CAAV,CAAjB;IAOA,KAAKI,MAAL,GAAc,IAAIlB,KAAJ,CAAU;MACvBQ,OAAO,EAAE,KAAKA,OADS;MAEvBO,KAAK,EAAE,KAAKL,WAAL,CAAiBQ,MAFD;MAGvBF,KAAK,EAAE,OAHgB;MAIvBC,KAAK,EAAEN,OAAO,CAACO;IAJQ,CAAV,CAAd;IAOAf,QAAQ,CAAC,IAAD,EAAO,CAAC,WAAD,EAAc,QAAd,CAAP,CAAR;EACA;;EAEiB,OAAXG,WAAW;IACjB,OAAOa,MAAM,CAACC,MAAP,CAAclB,aAAa,CAACI,WAAd,EAAd,EAA2C;MACjDY,MAAM,EAAE,CADyC;MAEjDJ,SAAS,EAAE,GAFsC;MAGjDD,IAAI,EAAE;IAH2C,CAA3C,CAAP;EAKA;EAED;;;;;;EAIAQ,KAAK,CAACC,IAAD,EAAY;IAChB,MAAMC,YAAY,GAAG,KAAKC,SAAL,CAAeF,IAAf,CAArB;IACA,KAAKG,GAAL,CAAS,OAAT,EAAkBF,YAAlB;;IACA,KAAKG,UAAL,CAAgBH,YAAhB;;IACA,KAAKb,WAAL,CAAiBW,KAAjB,CAAuBE,YAAvB;;IACA,OAAO,IAAP;EACA;;EAESI,WAAW,CAACL,IAAD,EAAe;IACnC,KAAKZ,WAAL,CAAiBkB,IAAjB,CAAsBN,IAAtB;EACA;EAED;;;;;;EAIAO,eAAe,CAACC,YAAD,EAA2B;IACzC,KAAKpB,WAAL,CAAiBmB,eAAjB,CAAiCC,YAAjC;;IACA,OAAO,IAAP;EACA;EAED;;;;;EAGQ,IAAJjB,IAAI;IACP,OAAO,KAAKH,WAAL,CAAiBG,IAAxB;EACA;;EACO,IAAJA,IAAI,CAACA,IAAD,EAAqB;IAC5B,KAAKH,WAAL,CAAiBG,IAAjB,GAAwBA,IAAxB;EACA;EAED;;;;;EAGAkB,OAAO;IACN,MAAMA,OAAN;;IACA,IAAI,KAAKC,KAAL,KAAe,SAAnB,EAA8B;MAC7B,KAAKJ,IAAL;IACA;;IACD,KAAKlB,WAAL,CAAiBuB,UAAjB;;IACA,KAAKnB,SAAL,CAAeiB,OAAf;IACA,KAAKb,MAAL,CAAYa,OAAZ;IACA,OAAO,IAAP;EACA;;AA9G8E","names":["connect","Param","optionsFromArguments","OneShotSource","readOnly","ToneOscillatorNode","constructor","getDefaults","arguments","context","createOscillator","_oscillator","options","_gainNode","type","frequency","param","units","value","detune","Object","assign","start","time","computedTime","toSeconds","log","_startGain","_stopSource","stop","setPeriodicWave","periodicWave","dispose","state","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/ToneOscillatorNode.ts"],"sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}