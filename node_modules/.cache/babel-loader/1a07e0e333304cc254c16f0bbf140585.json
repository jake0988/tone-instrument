{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport class OmniOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OmniOscillator\";\n    const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]); // set the options\n\n    this.set(options);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._oscillator.start(time);\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _stop(time) {\n    this._oscillator.stop(time);\n  }\n\n  _restart(time) {\n    this._oscillator.restart(time);\n\n    return this;\n  }\n  /**\n   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n   * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n   * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n   * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n   * when it's not.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n   * omniOsc.type = \"pwm\";\n   * // modulationFrequency is parameter which is available\n   * // only when the type is \"pwm\".\n   * omniOsc.modulationFrequency.value = 0.5;\n   */\n\n\n  get type() {\n    let prefix = \"\";\n\n    if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n      prefix = this._sourceType;\n    }\n\n    return prefix + this._oscillator.type;\n  }\n\n  set type(type) {\n    if (type.substr(0, 2) === \"fm\") {\n      this._createNewOscillator(\"fm\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 2) === \"am\") {\n      this._createNewOscillator(\"am\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 3) === \"fat\") {\n      this._createNewOscillator(\"fat\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(3);\n    } else if (type === \"pwm\") {\n      this._createNewOscillator(\"pwm\");\n\n      this._oscillator = this._oscillator;\n    } else if (type === \"pulse\") {\n      this._createNewOscillator(\"pulse\");\n    } else {\n      this._createNewOscillator(\"oscillator\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type;\n    }\n  }\n  /**\n   * The value is an empty array when the type is not \"custom\".\n   * This is not available on \"pwm\" and \"pulse\" oscillator types.\n   * See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partials = partials;\n    }\n  }\n\n  get partialCount() {\n    return this._oscillator.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partialCount = partialCount;\n    }\n  }\n\n  set(props) {\n    // make sure the type is set first\n    if (Reflect.has(props, \"type\") && props.type) {\n      this.type = props.type;\n    } // then set the rest\n\n\n    super.set(props);\n    return this;\n  }\n  /**\n   * connect the oscillator to the frequency and detune signals\n   */\n\n\n  _createNewOscillator(oscType) {\n    if (oscType !== this._sourceType) {\n      this._sourceType = oscType;\n      const OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change\n\n      const now = this.now();\n\n      if (this._oscillator) {\n        const oldOsc = this._oscillator;\n        oldOsc.stop(now); // dispose the old one\n\n        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n      }\n\n      this._oscillator = new OscConstructor({\n        context: this.context\n      });\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n\n      this._oscillator.connect(this.output);\n\n      this._oscillator.onstop = () => this.onstop(this);\n\n      if (this.state === \"started\") {\n        this._oscillator.start(now);\n      }\n    }\n  }\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n  }\n  /**\n   * The source type of the oscillator.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n   * console.log(omniOsc.sourceType); // 'fm'\n   */\n\n\n  get sourceType() {\n    return this._sourceType;\n  }\n\n  set sourceType(sType) {\n    // the basetype defaults to sine\n    let baseType = \"sine\";\n\n    if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n      baseType = this._oscillator.type;\n    } // set the type\n\n\n    if (sType === \"fm\") {\n      this.type = \"fm\" + baseType;\n    } else if (sType === \"am\") {\n      this.type = \"am\" + baseType;\n    } else if (sType === \"fat\") {\n      this.type = \"fat\" + baseType;\n    } else if (sType === \"oscillator\") {\n      this.type = baseType;\n    } else if (sType === \"pulse\") {\n      this.type = \"pulse\";\n    } else if (sType === \"pwm\") {\n      this.type = \"pwm\";\n    }\n  }\n\n  _getOscType(osc, sourceType) {\n    return osc instanceof OmniOscillatorSourceMap[sourceType];\n  }\n  /**\n   * The base type of the oscillator. See [[Oscillator.baseType]]\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n   */\n\n\n  get baseType() {\n    return this._oscillator.baseType;\n  }\n\n  set baseType(baseType) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n      this._oscillator.baseType = baseType;\n    }\n  }\n  /**\n   * The width of the oscillator when sourceType === \"pulse\".\n   * See [[PWMOscillator.width]]\n   */\n\n\n  get width() {\n    if (this._getOscType(this._oscillator, \"pulse\")) {\n      return this._oscillator.width;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The number of detuned oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get count() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.count;\n    } else {\n      return undefined;\n    }\n  }\n\n  set count(count) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n      this._oscillator.count = count;\n    }\n  }\n  /**\n   * The detune spread between the oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get spread() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.spread;\n    } else {\n      return undefined;\n    }\n  }\n\n  set spread(spread) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n      this._oscillator.spread = spread;\n    }\n  }\n  /**\n   * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get modulationType() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.modulationType;\n    } else {\n      return undefined;\n    }\n  }\n\n  set modulationType(mType) {\n    if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n      this._oscillator.modulationType = mType;\n    }\n  }\n  /**\n   * The modulation index when the sourceType === \"fm\"\n   * See [[FMOscillator]].\n   */\n\n\n  get modulationIndex() {\n    if (this._getOscType(this._oscillator, \"fm\")) {\n      return this._oscillator.modulationIndex;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get harmonicity() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.harmonicity;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n   * see [[PWMOscillator]]\n   * @min 0.1\n   * @max 5\n   */\n\n\n  get modulationFrequency() {\n    if (this._getOscType(this._oscillator, \"pwm\")) {\n      return this._oscillator.modulationFrequency;\n    } else {\n      return undefined;\n    }\n  }\n\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.detune.dispose();\n    this.frequency.dispose();\n\n    this._oscillator.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["optionsFromArguments","readOnly","isNumber","isString","Signal","Source","AMOscillator","FatOscillator","FMOscillator","Oscillator","generateWaveform","PulseOscillator","PWMOscillator","OmniOscillatorSourceMap","am","fat","fm","oscillator","pulse","pwm","OmniOscillator","constructor","getDefaults","arguments","options","frequency","context","units","value","detune","set","Object","assign","_start","time","_oscillator","start","_stop","stop","_restart","restart","type","prefix","some","p","_sourceType","substr","_createNewOscillator","partials","_getOscType","partialCount","props","Reflect","has","oscType","OscConstructor","now","oldOsc","setTimeout","dispose","blockTime","connect","output","onstop","state","phase","sourceType","sType","baseType","osc","width","undefined","count","spread","modulationType","mType","modulationIndex","harmonicity","modulationFrequency","asArray","length"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/OmniOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorOptions, \n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one. \n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}