{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\n\nexport class PhaseShiftAllpass extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"PhaseShiftAllpass\";\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The phase shifted output\n     */\n\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n\n    this.offset90 = new Gain({\n      context: this.context\n    });\n    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n    const allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n    this._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]); // connect Allpass filter banks\n\n    connectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n    connectSeries(this.input, ...this._bank1, this.offset90);\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n\n\n  _createAllPassFilterBank(bankValues) {\n    const nodes = bankValues.map(value => {\n      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n      return this.context.createIIRFilter(coefficients[0], coefficients[1]);\n    });\n    return nodes;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.offset90.dispose();\n\n    this._bank0.forEach(f => f.disconnect());\n\n    this._bank1.forEach(f => f.disconnect());\n\n    this._oneSampleDelay.disconnect();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAqB,yBAArB;AACA,SAASC,aAAT,EAAwBC,aAAxB,QAAmE,kCAAnE;AAEA;;;;;;;;;AAQA,OAAM,MAAOC,iBAAP,SAAiCD,aAAjC,CAAoE;EA+BzEE,YAAYC,OAAZ,EAAmD;IAElD,MAAMA,OAAN;IA/BQ,YAAe,mBAAf;IAEA,aAAQ,IAAIL,IAAJ,CAAS;MAAEM,OAAO,EAAE,KAAKA;IAAhB,CAAT,CAAR;IAiBT;;;;IAGS,cAAS,IAAIN,IAAJ,CAAS;MAAEM,OAAO,EAAE,KAAKA;IAAhB,CAAT,CAAT;IAET;;;;IAGS,gBAAW,IAAIN,IAAJ,CAAS;MAAEM,OAAO,EAAE,KAAKA;IAAhB,CAAT,CAAX;IAMR,MAAMC,kBAAkB,GAAG,CAAC,SAAD,EAAY,eAAZ,EAA6B,eAA7B,EAA8C,eAA9C,CAA3B;IACA,MAAMC,kBAAkB,GAAG,CAAC,eAAD,EAAkB,eAAlB,EAAmC,eAAnC,EAAoD,eAApD,CAA3B;IAEA,KAAKC,MAAL,GAAc,KAAKC,wBAAL,CAA8BH,kBAA9B,CAAd;IACA,KAAKI,MAAL,GAAc,KAAKD,wBAAL,CAA8BF,kBAA9B,CAAd;IACA,KAAKI,eAAL,GAAuB,KAAKN,OAAL,CAAaO,eAAb,CAA6B,CAAC,GAAD,EAAM,GAAN,CAA7B,EAAyC,CAAC,GAAD,EAAM,GAAN,CAAzC,CAAvB,CATkD,CAWlD;;IACAZ,aAAa,CAAC,KAAKa,KAAN,EAAa,GAAG,KAAKL,MAArB,EAA6B,KAAKG,eAAlC,EAAmD,KAAKG,MAAxD,CAAb;IACAd,aAAa,CAAC,KAAKa,KAAN,EAAa,GAAG,KAAKH,MAArB,EAA6B,KAAKK,QAAlC,CAAb;EACA;EAED;;;;;EAGQN,wBAAwB,CAACO,UAAD,EAAqB;IACpD,MAAMC,KAAK,GAAoBD,UAAU,CAACE,GAAX,CAAeC,KAAK,IAAG;MACrD,MAAMC,YAAY,GAAG,CAAC,CAACD,KAAK,GAAGA,KAAT,EAAgB,CAAhB,EAAmB,CAAC,CAApB,CAAD,EAAyB,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAEA,KAAK,GAAGA,KAAV,CAAP,CAAzB,CAArB;MACA,OAAO,KAAKd,OAAL,CAAaO,eAAb,CAA6BQ,YAAY,CAAC,CAAD,CAAzC,EAA8CA,YAAY,CAAC,CAAD,CAA1D,CAAP;IACA,CAH8B,CAA/B;IAKA,OAAOH,KAAP;EACA;;EAEDI,OAAO;IACN,MAAMA,OAAN;IACA,KAAKR,KAAL,CAAWQ,OAAX;IACA,KAAKP,MAAL,CAAYO,OAAZ;IACA,KAAKN,QAAL,CAAcM,OAAd;;IACA,KAAKb,MAAL,CAAYc,OAAZ,CAAoBC,CAAC,IAAIA,CAAC,CAACC,UAAF,EAAzB;;IACA,KAAKd,MAAL,CAAYY,OAAZ,CAAoBC,CAAC,IAAIA,CAAC,CAACC,UAAF,EAAzB;;IACA,KAAKb,eAAL,CAAqBa,UAArB;;IACA,OAAO,IAAP;EACA;;AApEwE","names":["Gain","connectSeries","ToneAudioNode","PhaseShiftAllpass","constructor","options","context","allpassBank1Values","allpassBank2Values","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","createIIRFilter","input","output","offset90","bankValues","nodes","map","value","coefficients","dispose","forEach","f","disconnect"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/filter/PhaseShiftAllpass.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}