{"ast":null,"code":"import { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\n\nexport class Pattern extends Loop {\n  constructor() {\n    super(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n    this.name = \"Pattern\";\n    const options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n    this.callback = options.callback;\n    this._values = options.values;\n    this._pattern = PatternGenerator(options.values, options.pattern);\n    this._type = options.pattern;\n  }\n\n  static getDefaults() {\n    return Object.assign(Loop.getDefaults(), {\n      pattern: \"up\",\n      values: [],\n      callback: noOp\n    });\n  }\n  /**\n   * Internal function called when the notes should be called\n   */\n\n\n  _tick(time) {\n    const value = this._pattern.next();\n\n    this._value = value.value;\n    this.callback(time, this._value);\n  }\n  /**\n   * The array of events.\n   */\n\n\n  get values() {\n    return this._values;\n  }\n\n  set values(val) {\n    this._values = val; // reset the pattern\n\n    this.pattern = this._type;\n  }\n  /**\n   * The current value of the pattern.\n   */\n\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n   */\n\n\n  get pattern() {\n    return this._type;\n  }\n\n  set pattern(pattern) {\n    this._type = pattern;\n    this._pattern = PatternGenerator(this._values, this._type);\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAkC,QAAlC;AACA,SAASC,gBAAT,QAA8C,oBAA9C;AAEA,SAASC,oBAAT,QAAqC,uBAArC;AAEA,SAASC,IAAT,QAAqB,wBAArB;AAQA;;;;;;;;;;AASA,OAAM,MAAOC,OAAP,SAAkCJ,IAAlC,CAAiE;EAwCtEK;IAEC,MAAMH,oBAAoB,CAACE,OAAO,CAACE,WAAR,EAAD,EAAwBC,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAA1B;IAxCQ,YAAe,SAAf;IAyCR,MAAMC,OAAO,GAAGN,oBAAoB,CAACE,OAAO,CAACE,WAAR,EAAD,EAAwBC,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAApC;IAEA,KAAKE,QAAL,GAAgBD,OAAO,CAACC,QAAxB;IACA,KAAKC,OAAL,GAAeF,OAAO,CAACG,MAAvB;IACA,KAAKC,QAAL,GAAgBX,gBAAgB,CAACO,OAAO,CAACG,MAAT,EAAiBH,OAAO,CAACK,OAAzB,CAAhC;IACA,KAAKC,KAAL,GAAaN,OAAO,CAACK,OAArB;EACA;;EAEiB,OAAXP,WAAW;IACjB,OAAOS,MAAM,CAACC,MAAP,CAAchB,IAAI,CAACM,WAAL,EAAd,EAAkC;MACxCO,OAAO,EAAE,IAD+B;MAExCF,MAAM,EAAE,EAFgC;MAGxCF,QAAQ,EAAEN;IAH8B,CAAlC,CAAP;EAKA;EAED;;;;;EAGUc,KAAK,CAACC,IAAD,EAAc;IAC5B,MAAMC,KAAK,GAAG,KAAKP,QAAL,CAAcQ,IAAd,EAAd;;IACA,KAAKC,MAAL,GAAcF,KAAK,CAACA,KAApB;IACA,KAAKV,QAAL,CAAcS,IAAd,EAAoB,KAAKG,MAAzB;EACA;EAED;;;;;EAGU,IAANV,MAAM;IACT,OAAO,KAAKD,OAAZ;EACA;;EACS,IAANC,MAAM,CAACW,GAAD,EAAI;IACb,KAAKZ,OAAL,GAAeY,GAAf,CADa,CAEb;;IACA,KAAKT,OAAL,GAAe,KAAKC,KAApB;EACA;EAED;;;;;EAGS,IAALK,KAAK;IACR,OAAO,KAAKE,MAAZ;EACA;EAED;;;;;EAGW,IAAPR,OAAO;IACV,OAAO,KAAKC,KAAZ;EACA;;EACU,IAAPD,OAAO,CAACA,OAAD,EAAQ;IAClB,KAAKC,KAAL,GAAaD,OAAb;IACA,KAAKD,QAAL,GAAgBX,gBAAgB,CAAC,KAAKS,OAAN,EAAe,KAAKI,KAApB,CAAhC;EACA;;AAhGqE","names":["Loop","PatternGenerator","optionsFromArguments","noOp","Pattern","constructor","getDefaults","arguments","options","callback","_values","values","_pattern","pattern","_type","Object","assign","_tick","time","value","next","_value","val"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/event/Pattern.ts"],"sourcesContent":["import { Loop, LoopOptions } from \"./Loop\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator\";\nimport { ToneEventCallback } from \"./ToneEvent\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Seconds } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns. \n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\n\treadonly name: string = \"Pattern\";\n\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<ValueType>;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName,\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(options.values, options.pattern);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as \"up\",\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst value = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._value = value.value;\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values, this._type);\n\t}\n}\n\n"]},"metadata":{},"sourceType":"module"}