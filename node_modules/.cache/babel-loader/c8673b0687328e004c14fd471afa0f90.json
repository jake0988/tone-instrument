{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\n\nexport class FFT extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n    this.name = \"FFT\";\n    const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    this.normalRange = options.normalRange;\n    this._analyser.type = \"fft\";\n    this.size = options.size;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalRange: false,\n      size: 1024,\n      smoothing: 0.8\n    });\n  }\n  /**\n   * Gets the current frequency data from the connected audio source.\n   * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n   */\n\n\n  getValue() {\n    const values = this._analyser.getValue();\n\n    return values.map(v => this.normalRange ? dbToGain(v) : v);\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   * Determines the size of the array returned by [[getValue]] (i.e. the number of\n   * frequency bins). Large FFT sizes may be costly to compute.\n   */\n\n\n  get size() {\n    return this._analyser.size;\n  }\n\n  set size(size) {\n    this._analyser.size = size;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analyser.smoothing;\n  }\n\n  set smoothing(val) {\n    this._analyser.smoothing = val;\n  }\n  /**\n   * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n   * @example\n   * const fft = new Tone.FFT(32);\n   * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n   */\n\n\n  getFrequencyOfIndex(index) {\n    assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n    return index * this.context.sampleRate / (this.size * 2);\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,aAAT,QAA8B,kCAA9B;AACA,SAASC,QAAT,QAAyB,6BAAzB;AAEA,SAASC,oBAAT,QAAqC,0BAArC;AACA,SAASC,SAAT,QAA4C,aAA5C;AACA,SAASC,MAAT,QAAuB,uBAAvB;AAQA;;;;;AAIA,OAAM,MAAOC,GAAP,SAAmBF,SAAnB,CAAwC;EAgB7CG;IACC,MAAMJ,oBAAoB,CAACG,GAAG,CAACE,WAAJ,EAAD,EAAoBC,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAA1B;IAfQ,YAAe,KAAf;IAgBR,MAAMC,OAAO,GAAGP,oBAAoB,CAACG,GAAG,CAACE,WAAJ,EAAD,EAAoBC,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAApC;IAEA,KAAKE,WAAL,GAAmBD,OAAO,CAACC,WAA3B;IACA,KAAKC,SAAL,CAAeC,IAAf,GAAsB,KAAtB;IACA,KAAKC,IAAL,GAAYJ,OAAO,CAACI,IAApB;EACA;;EAEiB,OAAXN,WAAW;IACjB,OAAOO,MAAM,CAACC,MAAP,CAAcf,aAAa,CAACO,WAAd,EAAd,EAA2C;MACjDG,WAAW,EAAE,KADoC;MAEjDG,IAAI,EAAE,IAF2C;MAGjDG,SAAS,EAAE;IAHsC,CAA3C,CAAP;EAKA;EAED;;;;;;EAIAC,QAAQ;IACP,MAAMC,MAAM,GAAG,KAAKP,SAAL,CAAeM,QAAf,EAAf;;IACA,OAAOC,MAAM,CAACC,GAAP,CAAWC,CAAC,IAAI,KAAKV,WAAL,GAAmBT,QAAQ,CAACmB,CAAD,CAA3B,GAAiCA,CAAjD,CAAP;EACA;EAED;;;;;;;EAKQ,IAAJP,IAAI;IACP,OAAO,KAAKF,SAAL,CAAeE,IAAtB;EACA;;EACO,IAAJA,IAAI,CAACA,IAAD,EAAK;IACZ,KAAKF,SAAL,CAAeE,IAAf,GAAsBA,IAAtB;EACA;EAED;;;;;EAGa,IAATG,SAAS;IACZ,OAAO,KAAKL,SAAL,CAAeK,SAAtB;EACA;;EACY,IAATA,SAAS,CAACK,GAAD,EAAI;IAChB,KAAKV,SAAL,CAAeK,SAAf,GAA2BK,GAA3B;EACA;EAED;;;;;;;;EAMAC,mBAAmB,CAACC,KAAD,EAAc;IAChCnB,MAAM,CAAC,KAAKmB,KAAL,IAAcA,KAAK,GAAG,KAAKV,IAA5B,EAAkC,0DAA0D,KAAKA,IAAI,EAArG,CAAN;IACA,OAAOU,KAAK,GAAG,KAAKC,OAAL,CAAaC,UAArB,IAAmC,KAAKZ,IAAL,GAAY,CAA/C,CAAP;EACA;;AAzE4C","names":["ToneAudioNode","dbToGain","optionsFromArguments","MeterBase","assert","FFT","constructor","getDefaults","arguments","options","normalRange","_analyser","type","size","Object","assign","smoothing","getValue","values","map","v","val","getFrequencyOfIndex","index","context","sampleRate"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/analysis/FFT.ts"],"sourcesContent":["import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { Hertz, NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\tconst values = this._analyser.getValue() as Float32Array;\n\t\treturn values.map(v => this.normalRange ? dbToGain(v) : v);\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]] (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n\n\t/**\n\t * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n\t * @example\n\t * const fft = new Tone.FFT(32);\n\t * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n\t */\n\tgetFrequencyOfIndex(index: number): Hertz {\n\t\tassert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n\t\treturn index * this.context.sampleRate / (this.size * 2);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}