{"ast":null,"code":"import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nexport class PolySynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    this._averageActiveVoices = 0;\n    const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    const defaults = options.voice.getDefaults();\n    this.options = Object.assign(defaults, options.options);\n    this.voice = options.voice;\n    this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    this._dummyVoice = this._getNextAvailableVoice(); // remove it from the voices list\n\n    const index = this._voices.indexOf(this._dummyVoice);\n\n    this._voices.splice(index, 1); // kick off the GC interval\n\n\n    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  }\n  /**\n   * The number of active voices.\n   */\n\n\n  get activeVoices() {\n    return this._activeVoices.length;\n  }\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n\n\n  _makeVoiceAvailable(voice) {\n    this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);\n\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  }\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n\n\n  _getNextAvailableVoice() {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      const voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      voice.connect(this.output);\n\n      this._voices.push(voice);\n\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  }\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n\n\n  _collectGarbage() {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      const firstAvail = this._availableVoices.shift();\n\n      const index = this._voices.indexOf(firstAvail);\n\n      this._voices.splice(index, 1);\n\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  }\n  /**\n   * Internal method which triggers the attack\n   */\n\n\n  _triggerAttack(notes, time, velocity) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const voice = this._getNextAvailableVoice();\n\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n\n        this._activeVoices.push({\n          midi: midiNote,\n          voice,\n          released: false\n        });\n\n        this.log(\"triggerAttack\", note, time);\n      }\n    });\n  }\n  /**\n   * Internal method which triggers the release\n   */\n\n\n  _triggerRelease(notes, time) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const event = this._activeVoices.find(_ref => {\n        let {\n          midi,\n          released\n        } = _ref;\n        return midi === midiNote && !released;\n      });\n\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time); // mark it as released\n\n        event.released = true;\n        this.log(\"triggerRelease\", note, time);\n      }\n    });\n  }\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n\n\n  _scheduleEvent(type, notes, time, velocity) {\n    assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(() => {\n        this._scheduleEvent(type, notes, time, velocity);\n      }, time - this.now());\n    }\n  }\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n   */\n\n\n  triggerAttack(notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n    return this;\n  }\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n\n\n  triggerRelease(notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"release\", notes, computedTime);\n\n    return this;\n  }\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n\n\n  triggerAttackRelease(notes, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n\n      for (let i = 0; i < notes.length; i++) {\n        const d = duration[Math.min(i, duration.length - 1)];\n        const durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      const durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n\n    return this;\n  }\n\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n\n    return this;\n  }\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * const poly = new Tone.PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n\n\n  set(options) {\n    // remove options which are controlled by the PolySynth\n    const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n    this.options = deepMerge(this.options, sanitizedOptions);\n\n    this._voices.forEach(voice => voice.set(sanitizedOptions));\n\n    this._dummyVoice.set(sanitizedOptions);\n\n    return this;\n  }\n\n  get() {\n    return this._dummyVoice.get();\n  }\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeVoices.forEach(_ref2 => {\n      let {\n        voice\n      } = _ref2;\n      voice.triggerRelease(computedTime);\n    });\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dummyVoice.dispose();\n\n    this._voices.forEach(v => v.dispose());\n\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,mBAA1B;AAEA,SAASC,SAAT,EAAoBC,cAApB,EAAoCC,oBAApC,QAAgE,uBAAhE;AAEA,SAASC,OAAT,EAAkBC,QAAlB,QAAkC,wBAAlC;AACA,SAASC,UAAT,QAA8C,cAA9C;AAOA,SAASC,KAAT,QAAoC,SAApC;AACA,SAASC,MAAT,EAAiBC,IAAjB,QAA6B,oBAA7B;AA4BA;;;;;;;;;;;;;;;;AAeA,OAAM,MAAOC,SAAP,SAAgEJ,UAAhE,CAA+F;EA0DpGK;IAEC,MAAMR,oBAAoB,CAACO,SAAS,CAACE,WAAV,EAAD,EAA0BC,SAA1B,EAAqC,CAAC,OAAD,EAAU,SAAV,CAArC,CAA1B;IA1DQ,YAAe,WAAf;IAET;;;;IAGQ,wBAA4B,EAA5B;IAER;;;;IAGQ,qBAA4E,EAA5E;IAER;;;;IAGQ,eAAmB,EAAnB;IAsBR;;;;IAGQ,kBAAa,CAAC,CAAd;IAER;;;;IAGQ,4BAAuB,CAAvB;IAcP,MAAMC,OAAO,GAAGX,oBAAoB,CAACO,SAAS,CAACE,WAAV,EAAD,EAA0BC,SAA1B,EAAqC,CAAC,OAAD,EAAU,SAAV,CAArC,CAApC,CAHD,CAKC;;IACAL,MAAM,CAAC,CAACH,QAAQ,CAACS,OAAO,CAACC,KAAT,CAAV,EAA2B,kEAA3B,CAAN;IAEA,MAAMC,QAAQ,GAAGF,OAAO,CAACC,KAAR,CAAcH,WAAd,EAAjB;IACA,KAAKE,OAAL,GAAeG,MAAM,CAACC,MAAP,CAAcF,QAAd,EAAwBF,OAAO,CAACA,OAAhC,CAAf;IACA,KAAKC,KAAL,GAAaD,OAAO,CAACC,KAArB;IACA,KAAKI,YAAL,GAAoBL,OAAO,CAACK,YAA5B,CAXD,CAaC;;IACA,KAAKC,WAAL,GAAmB,KAAKC,sBAAL,EAAnB,CAdD,CAeC;;IACA,MAAMC,KAAK,GAAG,KAAKC,OAAL,CAAaC,OAAb,CAAqB,KAAKJ,WAA1B,CAAd;;IACA,KAAKG,OAAL,CAAaE,MAAb,CAAoBH,KAApB,EAA2B,CAA3B,EAjBD,CAkBC;;;IACA,KAAKI,UAAL,GAAkB,KAAKC,OAAL,CAAaC,WAAb,CAAyB,KAAKC,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAAzB,EAA0D,CAA1D,CAAlB;EACA;;EAEiB,OAAXlB,WAAW;IACjB,OAAOK,MAAM,CAACC,MAAP,CAAcZ,UAAU,CAACM,WAAX,EAAd,EAAwC;MAC9CO,YAAY,EAAE,EADgC;MAE9CL,OAAO,EAAE,EAFqC;MAG9CC,KAAK,EAAER;IAHuC,CAAxC,CAAP;EAKA;EAED;;;;;EAGgB,IAAZwB,YAAY;IACf,OAAO,KAAKC,aAAL,CAAmBC,MAA1B;EACA;EAED;;;;;;EAIQC,mBAAmB,CAACnB,KAAD,EAAa;IACvC,KAAKoB,gBAAL,CAAsBC,IAAtB,CAA2BrB,KAA3B,EADuC,CAEvC;;;IACA,MAAMsB,gBAAgB,GAAG,KAAKL,aAAL,CAAmBM,SAAnB,CAA8BC,CAAD,IAAOA,CAAC,CAACxB,KAAF,KAAYA,KAAhD,CAAzB;;IACA,KAAKiB,aAAL,CAAmBP,MAAnB,CAA0BY,gBAA1B,EAA4C,CAA5C;EACA;EAED;;;;;;;EAKQhB,sBAAsB;IAC7B;IACA,IAAI,KAAKc,gBAAL,CAAsBF,MAA1B,EAAkC;MACjC,OAAO,KAAKE,gBAAL,CAAsBK,KAAtB,EAAP;IACA,CAFD,MAEO,IAAI,KAAKjB,OAAL,CAAaU,MAAb,GAAsB,KAAKd,YAA/B,EAA6C;MACnD;MACA,MAAMJ,KAAK,GAAG,IAAI,KAAKA,KAAT,CAAeE,MAAM,CAACC,MAAP,CAAc,KAAKJ,OAAnB,EAA4B;QACxDa,OAAO,EAAE,KAAKA,OAD0C;QAExDc,SAAS,EAAE,KAAKP,mBAAL,CAAyBJ,IAAzB,CAA8B,IAA9B;MAF6C,CAA5B,CAAf,CAAd;MAIAf,KAAK,CAAC2B,OAAN,CAAc,KAAKC,MAAnB;;MACA,KAAKpB,OAAL,CAAaa,IAAb,CAAkBrB,KAAlB;;MACA,OAAOA,KAAP;IACA,CATM,MASA;MACNN,IAAI,CAAC,uCAAD,CAAJ;IACA;EACD;EAED;;;;;EAGQoB,eAAe;IACtB,KAAKe,oBAAL,GAA4BC,IAAI,CAACC,GAAL,CAAS,KAAKF,oBAAL,GAA4B,IAArC,EAA2C,KAAKb,YAAhD,CAA5B;;IACA,IAAI,KAAKI,gBAAL,CAAsBF,MAAtB,IAAgC,KAAKV,OAAL,CAAaU,MAAb,GAAsBY,IAAI,CAACE,IAAL,CAAU,KAAKH,oBAAL,GAA4B,CAAtC,CAA1D,EAAoG;MACnG;MACA,MAAMI,UAAU,GAAG,KAAKb,gBAAL,CAAsBK,KAAtB,EAAnB;;MACA,MAAMlB,KAAK,GAAG,KAAKC,OAAL,CAAaC,OAAb,CAAqBwB,UAArB,CAAd;;MACA,KAAKzB,OAAL,CAAaE,MAAb,CAAoBH,KAApB,EAA2B,CAA3B;;MACA,IAAI,CAAC,KAAKK,OAAL,CAAasB,SAAlB,EAA6B;QAC5BD,UAAU,CAACE,OAAX;MACA;IACD;EACD;EAED;;;;;EAGQC,cAAc,CAACC,KAAD,EAAqBC,IAArB,EAAoCC,QAApC,EAA0D;IAC/EF,KAAK,CAACG,OAAN,CAAcC,IAAI,IAAG;MACpB,MAAMC,QAAQ,GAAG,IAAIzD,SAAJ,CAAc,KAAK2B,OAAnB,EAA4B6B,IAA5B,EAAkCE,MAAlC,EAAjB;;MACA,MAAM3C,KAAK,GAAG,KAAKM,sBAAL,EAAd;;MACA,IAAIN,KAAJ,EAAW;QACVA,KAAK,CAAC4C,aAAN,CAAoBH,IAApB,EAA0BH,IAA1B,EAAgCC,QAAhC;;QACA,KAAKtB,aAAL,CAAmBI,IAAnB,CAAwB;UACvBwB,IAAI,EAAEH,QADiB;UACP1C,KADO;UACA8C,QAAQ,EAAE;QADV,CAAxB;;QAGA,KAAKC,GAAL,CAAS,eAAT,EAA0BN,IAA1B,EAAgCH,IAAhC;MACA;IACD,CAVD;EAWA;EAED;;;;;EAGQU,eAAe,CAACX,KAAD,EAAqBC,IAArB,EAAkC;IACxDD,KAAK,CAACG,OAAN,CAAcC,IAAI,IAAG;MACpB,MAAMC,QAAQ,GAAG,IAAIzD,SAAJ,CAAc,KAAK2B,OAAnB,EAA4B6B,IAA5B,EAAkCE,MAAlC,EAAjB;;MACA,MAAMM,KAAK,GAAG,KAAKhC,aAAL,CAAmBiC,IAAnB,CAAwB;QAAA,IAAC;UAAEL,IAAF;UAAQC;QAAR,CAAD;QAAA,OAAwBD,IAAI,KAAKH,QAAT,IAAqB,CAACI,QAA9C;MAAA,CAAxB,CAAd;;MACA,IAAIG,KAAJ,EAAW;QACV;QACAA,KAAK,CAACjD,KAAN,CAAYmD,cAAZ,CAA2Bb,IAA3B,EAFU,CAGV;;QACAW,KAAK,CAACH,QAAN,GAAiB,IAAjB;QACA,KAAKC,GAAL,CAAS,gBAAT,EAA2BN,IAA3B,EAAiCH,IAAjC;MACA;IACD,CAVD;EAWA;EAED;;;;;;EAIQc,cAAc,CAACC,IAAD,EAA6BhB,KAA7B,EAAiDC,IAAjD,EAAgEC,QAAhE,EAAsF;IAC3G9C,MAAM,CAAC,CAAC,KAAK6D,QAAP,EAAiB,4BAAjB,CAAN,CAD2G,CAE3G;;IACA,IAAIhB,IAAI,IAAI,KAAKiB,GAAL,EAAZ,EAAwB;MACvB;MACA,IAAIF,IAAI,KAAK,QAAb,EAAuB;QACtB,KAAKjB,cAAL,CAAoBC,KAApB,EAA2BC,IAA3B,EAAiCC,QAAjC;MACA,CAFD,MAEO;QACN,KAAKS,eAAL,CAAqBX,KAArB,EAA4BC,IAA5B;MACA;IACD,CAPD,MAOO;MACN;MACA,KAAK1B,OAAL,CAAa4C,UAAb,CAAwB,MAAK;QAC5B,KAAKJ,cAAL,CAAoBC,IAApB,EAA0BhB,KAA1B,EAAiCC,IAAjC,EAAuCC,QAAvC;MACA,CAFD,EAEGD,IAAI,GAAG,KAAKiB,GAAL,EAFV;IAGA;EACD;EAED;;;;;;;;;;;;EAUAX,aAAa,CAACP,KAAD,EAAiCC,IAAjC,EAA8CC,QAA9C,EAAoE;IAEhF,IAAI,CAACkB,KAAK,CAACpE,OAAN,CAAcgD,KAAd,CAAL,EAA2B;MAC1BA,KAAK,GAAG,CAACA,KAAD,CAAR;IACA;;IACD,MAAMqB,YAAY,GAAG,KAAKC,SAAL,CAAerB,IAAf,CAArB;;IACA,KAAKc,cAAL,CAAoB,QAApB,EAA8Bf,KAA9B,EAAqCqB,YAArC,EAAmDnB,QAAnD;;IACA,OAAO,IAAP;EACA;EAED;;;;;;;;;;;;;;;EAaAY,cAAc,CAACd,KAAD,EAAiCC,IAAjC,EAA4C;IACzD,IAAI,CAACmB,KAAK,CAACpE,OAAN,CAAcgD,KAAd,CAAL,EAA2B;MAC1BA,KAAK,GAAG,CAACA,KAAD,CAAR;IACA;;IACD,MAAMqB,YAAY,GAAG,KAAKC,SAAL,CAAerB,IAAf,CAArB;;IACA,KAAKc,cAAL,CAAoB,SAApB,EAA+Bf,KAA/B,EAAsCqB,YAAtC;;IACA,OAAO,IAAP;EACA;EAED;;;;;;;;;;;;;EAWAE,oBAAoB,CACnBvB,KADmB,EAEnBwB,QAFmB,EAGnBvB,IAHmB,EAInBC,QAJmB,EAIG;IAEtB,MAAMmB,YAAY,GAAG,KAAKC,SAAL,CAAerB,IAAf,CAArB;IACA,KAAKM,aAAL,CAAmBP,KAAnB,EAA0BqB,YAA1B,EAAwCnB,QAAxC;;IACA,IAAIlD,OAAO,CAACwE,QAAD,CAAX,EAAuB;MACtBpE,MAAM,CAACJ,OAAO,CAACgD,KAAD,CAAR,EAAiB,8DAAjB,CAAN;MACAA,KAAK,GAAGA,KAAR;;MACA,KAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,KAAK,CAACnB,MAA1B,EAAkC4C,CAAC,EAAnC,EAAuC;QACtC,MAAMC,CAAC,GAAGF,QAAQ,CAAC/B,IAAI,CAACkC,GAAL,CAASF,CAAT,EAAYD,QAAQ,CAAC3C,MAAT,GAAkB,CAA9B,CAAD,CAAlB;QACA,MAAM+C,eAAe,GAAG,KAAKN,SAAL,CAAeI,CAAf,CAAxB;QACAtE,MAAM,CAACwE,eAAe,GAAG,CAAnB,EAAsB,qCAAtB,CAAN;QACA,KAAKd,cAAL,CAAoBd,KAAK,CAACyB,CAAD,CAAzB,EAA8BJ,YAAY,GAAGO,eAA7C;MACA;IACD,CATD,MASO;MACN,MAAMA,eAAe,GAAG,KAAKN,SAAL,CAAeE,QAAf,CAAxB;MACApE,MAAM,CAACwE,eAAe,GAAG,CAAnB,EAAsB,qCAAtB,CAAN;MACA,KAAKd,cAAL,CAAoBd,KAApB,EAA2BqB,YAAY,GAAGO,eAA1C;IACA;;IACD,OAAO,IAAP;EACA;;EAEDC,IAAI;IACH,IAAI,KAAKC,UAAL,EAAJ,EAAuB;MACtB,KAAKC,WAAL,CAAiB,eAAjB,EAAkC,CAAlC;;MACA,KAAKA,WAAL,CAAiB,gBAAjB,EAAmC,CAAnC;IACA;;IACD,OAAO,IAAP;EACA;EAED;;;;;;;;;;;;;;EAYAC,GAAG,CAACtE,OAAD,EAA+C;IACjD;IACA,MAAMuE,gBAAgB,GAAGnF,cAAc,CAACY,OAAD,EAAU,CAAC,WAAD,EAAc,SAAd,CAAV,CAAvC,CAFiD,CAGjD;;IACA,KAAKA,OAAL,GAAeb,SAAS,CAAC,KAAKa,OAAN,EAAeuE,gBAAf,CAAxB;;IACA,KAAK9D,OAAL,CAAagC,OAAb,CAAqBxC,KAAK,IAAIA,KAAK,CAACqE,GAAN,CAAUC,gBAAV,CAA9B;;IACA,KAAKjE,WAAL,CAAiBgE,GAAjB,CAAqBC,gBAArB;;IACA,OAAO,IAAP;EACA;;EAEDC,GAAG;IACF,OAAO,KAAKlE,WAAL,CAAiBkE,GAAjB,EAAP;EACA;EAED;;;;;;EAIAC,UAAU,CAAClC,IAAD,EAAY;IACrB,MAAMoB,YAAY,GAAG,KAAKC,SAAL,CAAerB,IAAf,CAArB;;IACA,KAAKrB,aAAL,CAAmBuB,OAAnB,CAA2B,SAAc;MAAA,IAAb;QAAExC;MAAF,CAAa;MACxCA,KAAK,CAACmD,cAAN,CAAqBO,YAArB;IACA,CAFD;;IAGA,OAAO,IAAP;EACA;;EAEDvB,OAAO;IACN,MAAMA,OAAN;;IACA,KAAK9B,WAAL,CAAiB8B,OAAjB;;IACA,KAAK3B,OAAL,CAAagC,OAAb,CAAqBiC,CAAC,IAAIA,CAAC,CAACtC,OAAF,EAA1B;;IACA,KAAKlB,aAAL,GAAqB,EAArB;IACA,KAAKG,gBAAL,GAAwB,EAAxB;IACA,KAAKR,OAAL,CAAa8D,aAAb,CAA2B,KAAK/D,UAAhC;IACA,OAAO,IAAP;EACA;;AA7UmG","names":["MidiClass","deepMerge","omitFromObject","optionsFromArguments","isArray","isNumber","Instrument","Synth","assert","warn","PolySynth","constructor","getDefaults","arguments","options","voice","defaults","Object","assign","maxPolyphony","_dummyVoice","_getNextAvailableVoice","index","_voices","indexOf","splice","_gcTimeout","context","setInterval","_collectGarbage","bind","activeVoices","_activeVoices","length","_makeVoiceAvailable","_availableVoices","push","activeVoiceIndex","findIndex","e","shift","onsilence","connect","output","_averageActiveVoices","Math","max","ceil","firstAvail","isOffline","dispose","_triggerAttack","notes","time","velocity","forEach","note","midiNote","toMidi","triggerAttack","midi","released","log","_triggerRelease","event","find","triggerRelease","_scheduleEvent","type","disposed","now","setTimeout","Array","computedTime","toSeconds","triggerAttackRelease","duration","i","d","min","durationSeconds","sync","_syncState","_syncMethod","set","sanitizedOptions","get","releaseAll","v","clearInterval"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/instrument/PolySynth.ts"],"sourcesContent":["import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends MonoSynth ? MonoSynthOptions :\n\t\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{ midi: MidiNote; voice: Voice; released: boolean }> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}