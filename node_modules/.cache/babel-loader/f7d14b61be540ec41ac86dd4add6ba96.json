{"ast":null,"code":"import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\n\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n\n    this._restart();\n  }\n\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time); // call the super class\n\n\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TicksClass","TransportEvent","TransportRepeatEvent","constructor","transport","opts","time","_restart","bind","options","Object","assign","getDefaults","duration","context","valueOf","_interval","interval","_nextTick","on","_boundRestart","Infinity","once","invoke","_createEvents","ticks","getTicksAtTime","_currentId","_nextId","scheduleOnce","toSeconds","clear","Math","ceil","dispose","off"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/TransportRepeatEvent.ts"],"sourcesContent":["import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}