{"ast":null,"code":"import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Transport extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Transport.getDefaults(), arguments));\n    this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    this._swingAmount = 0;\n    const options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    this._ppq = options.ppq;\n    this._clock = new Clock({\n      callback: this._processTick.bind(this),\n      context: this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    this._bindClockEvents();\n\n    this.bpm = this._clock.frequency;\n    this._clock.frequency.multiplier = options.ppq;\n    this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(this, \"bpm\");\n    this._timeSignature = options.timeSignature; // SWING\n\n    this._swingTicks = options.ppq / 2; // 8n\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  } //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n\n\n  _processTick(tickTime, ticks) {\n    // do the loop test\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } // handle swing\n\n\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    } // invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n  } //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * // schedule an event on the 16th measure\n   * Tone.Transport.schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n\n\n  schedule(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Tone.Transport.scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n\n\n  scheduleRepeat(callback, interval, startTime) {\n    let duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    const event = new TransportRepeatEvent(this, {\n      callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    }); // kick it off if the Transport is started\n    // @ts-ignore\n\n    return this._addEvent(event, this._repeatedEvents);\n  }\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n\n\n  scheduleOnce(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n\n\n  clear(eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      const item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  }\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n\n\n  _addEvent(event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event,\n      timeline\n    };\n    timeline.add(event);\n    return event.id;\n  }\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n\n\n  cancel() {\n    let after = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const computedAfter = this.toTicks(after);\n\n    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    return this;\n  } //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n\n\n  _bindClockEvents() {\n    this._clock.on(\"start\", (time, offset) => {\n      offset = new TicksClass(this.context, offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    });\n\n    this._clock.on(\"stop\", time => {\n      this.emit(\"stop\", time);\n    });\n\n    this._clock.on(\"pause\", time => {\n      this.emit(\"pause\", time);\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   */\n\n\n  get state() {\n    return this._clock.getStateAtTime(this.now());\n  }\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Tone.Transport.start(\"+1\", \"4:0:0\");\n   */\n\n\n  start(time, offset) {\n    let offsetTicks;\n\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    } // start the clock\n\n\n    this._clock.start(time, offsetTicks);\n\n    return this;\n  }\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * Tone.Transport.stop();\n   */\n\n\n  stop(time) {\n    this._clock.stop(time);\n\n    return this;\n  }\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n\n\n  pause(time) {\n    this._clock.pause(time);\n\n    return this;\n  }\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n\n\n  toggle(time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  } //-------------------------------------\n  // \tSETTERS/GETTERS\n  //-------------------------------------\n\n  /**\n   * The time signature as just the numerator over 4.\n   * For example 4/4 would be just 4 and 6/8 would be 3.\n   * @example\n   * // common time\n   * Tone.Transport.timeSignature = 4;\n   * // 7/8\n   * Tone.Transport.timeSignature = [7, 8];\n   * // this will be reduced to a single number\n   * Tone.Transport.timeSignature; // returns 3.5\n   */\n\n\n  get timeSignature() {\n    return this._timeSignature;\n  }\n\n  set timeSignature(timeSig) {\n    if (isArray(timeSig)) {\n      timeSig = timeSig[0] / timeSig[1] * 4;\n    }\n\n    this._timeSignature = timeSig;\n  }\n  /**\n   * When the Transport.loop = true, this is the starting position of the loop.\n   */\n\n\n  get loopStart() {\n    return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n  }\n\n  set loopStart(startPosition) {\n    this._loopStart = this.toTicks(startPosition);\n  }\n  /**\n   * When the Transport.loop = true, this is the ending position of the loop.\n   */\n\n\n  get loopEnd() {\n    return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n  }\n\n  set loopEnd(endPosition) {\n    this._loopEnd = this.toTicks(endPosition);\n  }\n  /**\n   * If the transport loops or not.\n   */\n\n\n  get loop() {\n    return this._loop.get(this.now());\n  }\n\n  set loop(loop) {\n    this._loop.set(loop, this.now());\n  }\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * // loop over the first measure\n   * Tone.Transport.setLoopPoints(0, \"1m\");\n   * Tone.Transport.loop = true;\n   */\n\n\n  setLoopPoints(startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  }\n  /**\n   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n   */\n\n\n  get swing() {\n    return this._swingAmount;\n  }\n\n  set swing(amount) {\n    // scale the values to a normal range\n    this._swingAmount = amount;\n  }\n  /**\n   * Set the subdivision which the swing will be applied to.\n   * The default value is an 8th note. Value must be less\n   * than a quarter note.\n   */\n\n\n  get swingSubdivision() {\n    return new TicksClass(this.context, this._swingTicks).toNotation();\n  }\n\n  set swingSubdivision(subdivision) {\n    this._swingTicks = this.toTicks(subdivision);\n  }\n  /**\n   * The Transport's position in Bars:Beats:Sixteenths.\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get position() {\n    const now = this.now();\n\n    const ticks = this._clock.getTicksAtTime(now);\n\n    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n  }\n\n  set position(progress) {\n    const ticks = this.toTicks(progress);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's position in seconds\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get seconds() {\n    return this._clock.seconds;\n  }\n\n  set seconds(s) {\n    const now = this.now();\n\n    const ticks = this._clock.frequency.timeToTicks(s, now);\n\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's loop position as a normalized value. Always\n   * returns 0 if the transport if loop is not true.\n   */\n\n\n  get progress() {\n    if (this.loop) {\n      const now = this.now();\n\n      const ticks = this._clock.getTicksAtTime(now);\n\n      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The transports current tick position.\n   */\n\n\n  get ticks() {\n    return this._clock.ticks;\n  }\n\n  set ticks(t) {\n    if (this._clock.ticks !== t) {\n      const now = this.now(); // stop everything synced to the transport\n\n      if (this.state === \"started\") {\n        const ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n\n        const time = now + remainingTick;\n        this.emit(\"stop\", time);\n\n        this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n        this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n      } else {\n        this._clock.setTicksAtTime(t, now);\n      }\n    }\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._clock.getSecondsAtTime(time);\n  }\n  /**\n   * Pulses Per Quarter note. This is the smallest resolution\n   * the Transport timing supports. This should be set once\n   * on initialization and not set again. Changing this value\n   * after other objects have been created can cause problems.\n   */\n\n\n  get PPQ() {\n    return this._clock.frequency.multiplier;\n  }\n\n  set PPQ(ppq) {\n    this._clock.frequency.multiplier = ppq;\n  } //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * // the transport must be started, otherwise returns 0\n   * Tone.Transport.start();\n   * Tone.Transport.nextSubdivision(\"4n\");\n   */\n\n\n  nextSubdivision(subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      const now = this.now(); // the remainder of the current ticks and the subdivision\n\n      const transportPos = this.getTicksAtTime(now);\n      const remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  }\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n\n\n  syncSignal(signal, ratio) {\n    if (!ratio) {\n      // get the sync ratio\n      const now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        const bpm = this.bpm.getValueAtTime(now);\n        const computedFreq = 1 / (60 / bpm / this.PPQ);\n        ratio = signal.getValueAtTime(now) / computedFreq;\n      } else {\n        ratio = 0;\n      }\n    }\n\n    const ratioSignal = new Gain(ratio); // @ts-ignore\n\n    this.bpm.connect(ratioSignal); // @ts-ignore\n\n    ratioSignal.connect(signal._param);\n\n    this._syncedSignals.push({\n      initial: signal.value,\n      ratio: ratioSignal,\n      signal\n    });\n\n    signal.value = 0;\n    return this;\n  }\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * See Transport.syncSignal.\n   */\n\n\n  unsyncSignal(signal) {\n    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n      const syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._clock.dispose();\n\n    writable(this, \"bpm\");\n\n    this._timeline.dispose();\n\n    this._repeatedEvents.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.transport = new Transport({\n    context\n  });\n});\nonContextClose(context => {\n  context.transport.dispose();\n});","map":{"version":3,"mappings":"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","names":["TimeClass","TimelineValue","onContextClose","onContextInit","Gain","ToneWithContext","TicksClass","TransportTimeClass","optionsFromArguments","Emitter","readOnly","writable","IntervalTimeline","Timeline","isArray","isDefined","Clock","TransportEvent","TransportRepeatEvent","Transport","constructor","getDefaults","arguments","options","_ppq","ppq","_clock","callback","_processTick","bind","context","frequency","units","_bindClockEvents","bpm","multiplier","setValueAtTime","_timeSignature","timeSignature","_swingTicks","Object","assign","loopEnd","loopStart","swing","swingSubdivision","tickTime","ticks","_loop","get","_loopEnd","emit","setTicksAtTime","_loopStart","getSecondsAtTime","_swingAmount","progress","amount","Math","sin","PI","toSeconds","_timeline","forEachAtTime","event","invoke","schedule","time","toTicks","_addEvent","scheduleRepeat","interval","startTime","duration","Infinity","_repeatedEvents","scheduleOnce","once","clear","eventId","_scheduledEvents","hasOwnProperty","item","toString","timeline","remove","dispose","id","add","cancel","after","computedAfter","forEachFrom","on","offset","state","getStateAtTime","now","start","offsetTicks","stop","pause","toggle","timeSig","startPosition","endPosition","loop","set","setLoopPoints","toNotation","subdivision","position","getTicksAtTime","toBarsBeatsSixteenths","seconds","s","timeToTicks","t","remainingTick","getDurationOfTicks","ceil","round","PPQ","nextSubdivision","transportPos","remainingTicks","nextTickTime","syncSignal","signal","ratio","getValueAtTime","computedFreq","ratioSignal","connect","_param","_syncedSignals","push","initial","value","unsyncSignal","i","length","syncedSignal","splice","mixin","transport"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/Transport.ts"],"sourcesContent":["import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport {\n\tBarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime\n} from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.Transport.bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.Transport.start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.Transport.schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.Transport.scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.Transport.timeSignature = 4;\n\t * // 7/8\n\t * Tone.Transport.timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.Transport.timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t * Tone.Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n\t\t\t\tconst time = now + remainingTick;\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.Transport.start(); \n\t * Tone.Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n"]},"metadata":{},"sourceType":"module"}