{"ast":null,"code":"import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\n\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\nexport function deepMerge(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  } // @ts-ignore\n\n\n  return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\n\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\n\nexport function optionsFromArguments(defaults, argsArray) {\n  let keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let objKey = arguments.length > 3 ? arguments[3] : undefined;\n  const opts = {};\n  const args = Array.from(argsArray); // if the first argument is an object and has an object key\n\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, {\n        [objKey]: args[0]\n      }); // remove the obj key from the keys\n\n      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off\n\n      args.shift();\n    }\n  }\n\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\n\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\n\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\n\nexport function omitFromObject(obj, omit) {\n  omit.forEach(prop => {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","map":{"version":3,"mappings":"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","names":["isAudioBuffer","isAudioNode","isAudioParam","isDefined","isObject","isUndef","noCopy","key","arg","deepMerge","target","sources","length","source","shift","Object","assign","deepEquals","arrayA","arrayB","every","element","index","optionsFromArguments","defaults","argsArray","keys","objKey","opts","args","Array","from","Reflect","has","partOfDefaults","some","splice","indexOf","i","getDefaultsFromInstance","instance","constructor","getDefaults","defaultArg","given","fallback","omitFromObject","obj","omit","forEach","prop"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/util/Defaults.ts"],"sourcesContent":["import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals<T>(arrayA: T[], arrayB: T[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: Array<keyof T> = [],\n\tobjKey?: keyof T,\n): T {\n\tconst opts: Partial<T> = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n"]},"metadata":{},"sourceType":"module"}