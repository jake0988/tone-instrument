{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\n\nexport class Timeline extends Tone {\n  constructor() {\n    super();\n    this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n\n    this._timeline = [];\n    const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    this.memory = options.memory;\n    this.increasing = options.increasing;\n  }\n\n  static getDefaults() {\n    return {\n      memory: Infinity,\n      increasing: false\n    };\n  }\n  /**\n   * The number of items in the timeline.\n   */\n\n\n  get length() {\n    return this._timeline.length;\n  }\n  /**\n   * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   * @param event  The event object to insert into the timeline.\n   */\n\n\n  add(event) {\n    // the event needs to have a time attribute\n    assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n    event.time = event.time.valueOf();\n\n    if (this.increasing && this.length) {\n      const lastValue = this._timeline[this.length - 1];\n      assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\n      this._timeline.push(event);\n    } else {\n      const index = this._search(event.time);\n\n      this._timeline.splice(index + 1, 0, event);\n    } // if the length is more than the memory, remove the previous ones\n\n\n    if (this.length > this.memory) {\n      const diff = this.length - this.memory;\n\n      this._timeline.splice(0, diff);\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  {Object}  event  The event object to remove from the list.\n   * @returns {Timeline} this\n   */\n\n\n  remove(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n\n    return this;\n  }\n  /**\n   * Get the nearest event whose time is less than or equal to the given time.\n   * @param  time  The time to query.\n   */\n\n\n  get(time) {\n    let param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n\n    const index = this._search(time, param);\n\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Return the first event in the timeline without removing it\n   * @returns {Object} The first event object\n   */\n\n\n  peek() {\n    return this._timeline[0];\n  }\n  /**\n   * Return the first event in the timeline and remove it\n   */\n\n\n  shift() {\n    return this._timeline.shift();\n  }\n  /**\n   * Get the event which is scheduled after the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getAfter(time) {\n    let param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n\n    const index = this._search(time, param);\n\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the event before the event at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getBefore(time) {\n    const len = this._timeline.length; // if it's after the last item, return the last item\n\n    if (len > 0 && this._timeline[len - 1].time < time) {\n      return this._timeline[len - 1];\n    }\n\n    const index = this._search(time);\n\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Cancel events at and after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    if (this._timeline.length > 1) {\n      let index = this._search(after);\n\n      if (index >= 0) {\n        if (EQ(this._timeline[index].time, after)) {\n          // get the first item with that time\n          for (let i = index; i >= 0; i--) {\n            if (EQ(this._timeline[i].time, after)) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      // the first item's time\n      if (GTE(this._timeline[0].time, after)) {\n        this._timeline = [];\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Cancel events before or equal to the given time.\n   * @param  time  The time to cancel before.\n   */\n\n\n  cancelBefore(time) {\n    const index = this._search(time);\n\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  event The event to find the previous one of\n   * @return The event right before the given event\n   */\n\n\n  previousEvent(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Does a binary search on the timeline array and returns the\n   * nearest event index whose time is after or equal to the given time.\n   * If a time is searched before the first index in the timeline, -1 is returned.\n   * If the time is after the end, the index of the last item is returned.\n   */\n\n\n  _search(time) {\n    let param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n\n    let beginning = 0;\n    const len = this._timeline.length;\n    let end = len;\n\n    if (len > 0 && this._timeline[len - 1][param] <= time) {\n      return len - 1;\n    }\n\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      let midPoint = Math.floor(beginning + (end - beginning) / 2);\n      const event = this._timeline[midPoint];\n      const nextEvent = this._timeline[midPoint + 1];\n\n      if (EQ(event[param], time)) {\n        // choose the last one that has the same time\n        for (let i = midPoint; i < this._timeline.length; i++) {\n          const testEvent = this._timeline[i];\n\n          if (EQ(testEvent[param], time)) {\n            midPoint = i;\n          } else {\n            break;\n          }\n        }\n\n        return midPoint;\n      } else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n        return midPoint;\n      } else if (GT(event[param], time)) {\n        // search lower\n        end = midPoint;\n      } else {\n        // search upper\n        beginning = midPoint + 1;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Internal iterator. Applies extra safety checks for\n   * removing items from the array.\n   */\n\n\n  _iterate(callback) {\n    let lowerBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let upperBound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._timeline.length - 1;\n\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n  }\n  /**\n   * Iterate over everything in the array\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    this._iterate(callback);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or before the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBefore(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array after the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAfter(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const lowerBound = this._search(time);\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array between the startTime and endTime.\n   * The timerange is inclusive of the startTime, but exclusive of the endTime.\n   * range = [startTime, endTime).\n   * @param  startTime The time to check if items are before\n   * @param  endTime The end of the test interval.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBetween(startTime, endTime, callback) {\n    let lowerBound = this._search(startTime);\n\n    let upperBound = this._search(endTime);\n\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      } // exclusive of the end time\n\n\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or after the given time. Similar to\n   * forEachAfter, but includes the item(s) at the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    let lowerBound = this._search(time); // work backwards until the event time is less than time\n\n\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at the given time\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n      let lowerBound = upperBound;\n\n      for (let i = upperBound; i >= 0; i--) {\n        if (EQ(this._timeline[i].time, time)) {\n          lowerBound = i;\n        } else {\n          break;\n        }\n      }\n\n      this._iterate(event => {\n        callback(event);\n      }, lowerBound, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._timeline = [];\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Tone","optionsFromArguments","assert","EQ","GT","GTE","LT","Timeline","constructor","options","getDefaults","arguments","memory","increasing","Infinity","length","_timeline","add","event","Reflect","has","time","valueOf","lastValue","push","index","_search","splice","diff","remove","indexOf","get","param","peek","shift","getAfter","getBefore","len","cancel","after","i","slice","cancelBefore","previousEvent","beginning","end","midPoint","Math","floor","nextEvent","testEvent","_iterate","callback","lowerBound","upperBound","forEach","forEachBefore","forEachAfter","forEachBetween","startTime","endTime","forEachFrom","forEachAtTime","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/util/Timeline.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tassert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tassert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n\t\t\tlet lowerBound = upperBound;\n\t\t\tfor (let i = upperBound; i >= 0; i--) {\n\t\t\t\tif (EQ(this._timeline[i].time, time)) {\n\t\t\t\t\tlowerBound = i;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._iterate(event => {\n\t\t\t\tcallback(event);\n\t\t\t}, lowerBound, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}