{"ast":null,"code":"import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\n\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (this._swappable) {\n      this.input = this.context.createGain(); // initialize\n\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n\n\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n\n\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n\n\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n\n\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n\n    const numericValue = this._fromType(value);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n    this._assertRange(numericValue);\n\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n\n    this._param.setValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n\n    const after = this._events.getAfter(computedTime);\n\n    const before = this._events.get(computedTime);\n\n    let value = this._initialValue; // if it was set by\n\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n\n      let previousVal;\n\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n\n    return this._toType(value);\n  }\n\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\n    this._assertRange(numericValue);\n\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value); // the value can't be 0\n\n\n    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\n    this._assertRange(numericValue);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`); // store the event\n\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n\n    this._assertRange(numericValue);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration) {\n    let scaling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\n    this._events.cancel(computedTime);\n\n    this._param.cancelScheduledValues(computedTime);\n\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n\n    const before = this._events.get(computedTime);\n\n    const after = this._events.getAfter(computedTime);\n\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n      this._events.cancel(after.time);\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    } // set the value at the given time\n\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n\n    this._param.setValueAtTime(valueAtTime, computedTime);\n\n    return this;\n  }\n\n  rampTo(value) {\n    let rampTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n    let startTime = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n\n\n  apply(param) {\n    const now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n    const previousEvent = this._events.get(now);\n\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n\n\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    return this;\n  }\n\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  } //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  } // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  } // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["dbToGain","gainToDb","isAudioParam","optionsFromArguments","Timeline","isDefined","ToneWithContext","EQ","assert","assertRange","Param","constructor","getDefaults","arguments","options","param","_param","_swappable","swappable","input","context","createGain","connect","_events","_initialValue","defaultValue","units","convert","_minValue","minValue","_maxValue","maxValue","value","_toType","setValueAtTime","Object","assign","now","getValueAtTime","cancelScheduledValues","Infinity","_is","arg","type","_assertRange","_fromType","val","overridden","toSeconds","toFrequency","time","computedTime","numericValue","isFinite","JSON","stringify","log","add","Math","max","after","getAfter","before","get","previous","getBefore","previousVal","_exponentialApproach","constant","beforeValue","_linearInterpolate","_exponentialInterpolate","setRampPoint","currentVal","cancelAndHoldAtTime","_minOutput","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","length","i","cancel","valueAtTime","sampleTime","rampTo","apply","currentTime","previousEvent","nextEvent","subdivisions","forEachAfter","event","setParam","disconnect","dispose","t0","v0","v1","t","exp","t1","pow"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/context/Param.ts"],"sourcesContent":["import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { Decibels, Frequency, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tassert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}