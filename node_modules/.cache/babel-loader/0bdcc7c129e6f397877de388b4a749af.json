{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\n\nexport class FatOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n\n    this._oscillators = [];\n    const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this._spread = options.spread;\n    this._type = options.type;\n    this._phase = options.phase;\n    this._partials = options.partials;\n    this._partialCount = options.partialCount; // set the count initially\n\n    this.count = options.count;\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      count: 3,\n      spread: 20,\n      type: \"sawtooth\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.start(time));\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.stop(time));\n  }\n\n  _restart(time) {\n    this._forEach(osc => osc.restart(time));\n  }\n  /**\n   * Iterate over all of the oscillators\n   */\n\n\n  _forEach(iterator) {\n    for (let i = 0; i < this._oscillators.length; i++) {\n      iterator(this._oscillators[i], i);\n    }\n  }\n  /**\n   * The type of the oscillator\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n\n    this._forEach(osc => osc.type = type);\n  }\n  /**\n   * The detune spread between the oscillators. If \"count\" is\n   * set to 3 oscillators and the \"spread\" is set to 40,\n   * the three oscillators would be detuned like this: [-20, 0, 20]\n   * for a total detune spread of 40 cents.\n   * @example\n   * const fatOsc = new Tone.FatOscillator().toDestination().start();\n   * fatOsc.spread = 70;\n   */\n\n\n  get spread() {\n    return this._spread;\n  }\n\n  set spread(spread) {\n    this._spread = spread;\n\n    if (this._oscillators.length > 1) {\n      const start = -spread / 2;\n      const step = spread / (this._oscillators.length - 1);\n\n      this._forEach((osc, i) => osc.detune.value = start + step * i);\n    }\n  }\n  /**\n   * The number of detuned oscillators. Must be an integer greater than 1.\n   * @example\n   * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n   * // use 4 sawtooth oscillators\n   * fatOsc.count = 4;\n   */\n\n\n  get count() {\n    return this._oscillators.length;\n  }\n\n  set count(count) {\n    assertRange(count, 1);\n\n    if (this._oscillators.length !== count) {\n      // dispose the previous oscillators\n      this._forEach(osc => osc.dispose());\n\n      this._oscillators = [];\n\n      for (let i = 0; i < count; i++) {\n        const osc = new Oscillator({\n          context: this.context,\n          volume: -6 - count * 1.1,\n          type: this._type,\n          phase: this._phase + i / count * 360,\n          partialCount: this._partialCount,\n          onstop: i === 0 ? () => this.onstop(this) : noOp\n        });\n\n        if (this.type === \"custom\") {\n          osc.partials = this._partials;\n        }\n\n        this.frequency.connect(osc.frequency);\n        this.detune.connect(osc.detune);\n        osc.detune.overridden = false;\n        osc.connect(this.output);\n        this._oscillators[i] = osc;\n      } // set the spread\n\n\n      this.spread = this._spread;\n\n      if (this.state === \"started\") {\n        this._forEach(osc => osc.start());\n      }\n    }\n  }\n\n  get phase() {\n    return this._phase;\n  }\n\n  set phase(phase) {\n    this._phase = phase;\n\n    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);\n  }\n\n  get baseType() {\n    return this._oscillators[0].baseType;\n  }\n\n  set baseType(baseType) {\n    this._forEach(osc => osc.baseType = baseType);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  get partials() {\n    return this._oscillators[0].partials;\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this._type = \"custom\";\n\n      this._forEach(osc => osc.partials = partials);\n    }\n  }\n\n  get partialCount() {\n    return this._oscillators[0].partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._partialCount = partialCount;\n\n    this._forEach(osc => osc.partialCount = partialCount);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._forEach(osc => osc.dispose());\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["optionsFromArguments","noOp","readOnly","Signal","Source","Oscillator","generateWaveform","assertRange","FatOscillator","constructor","getDefaults","arguments","options","frequency","context","units","value","detune","_spread","spread","_type","type","_phase","phase","_partials","partials","_partialCount","partialCount","count","Object","assign","_start","time","toSeconds","_forEach","osc","start","_stop","stop","_restart","restart","iterator","i","_oscillators","length","step","dispose","volume","onstop","connect","overridden","output","state","baseType","asArray"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/FatOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach(osc => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach((osc, i) => osc.phase = this._phase + (i / this.count) * 360);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}