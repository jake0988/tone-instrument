{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\"); // add an initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    this.context.on(\"tick\", this._boundLoop);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n\n\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context); // start the loop\n\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this._tickSource.start(computedTime, offset);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this._tickSource.stop(computedTime);\n\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n\n      this._tickSource.pause(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n\n\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n\n\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n\n\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n\n\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n\n            this.emit(\"start\", e.time, offset);\n            break;\n\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      }); // the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n\n\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._tickSource.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Clock);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","constructor","getDefaults","arguments","_loop","bind","options","callback","_tickSource","context","frequency","units","_lastUpdate","_state","setStateAtTime","on","_boundLoop","Object","assign","state","getValueAtTime","now","start","time","offset","computedTime","toSeconds","log","emit","stop","cancel","pause","ticks","Math","ceil","getTicksAtTime","t","seconds","s","getSecondsAtTime","setTicksAtTime","getTimeOfTick","tick","before","nextTickTime","when","currentTick","startTime","endTime","forEachBetween","e","forEachTickBetween","getStateAtTime","dispose","off","mixin"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/clock/Clock.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n"]},"metadata":{},"sourceType":"module"}