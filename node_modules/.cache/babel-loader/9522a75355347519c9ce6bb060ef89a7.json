{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\n\nexport class Envelope extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    this._sig = new Signal({\n      context: this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    this.output = this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    this.input = undefined;\n    const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    this.attack = options.attack;\n    this.decay = options.decay;\n    this.sustain = options.sustain;\n    this.release = options.release;\n    this.attackCurve = options.attackCurve;\n    this.releaseCurve = options.releaseCurve;\n    this.decayCurve = options.decayCurve;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.01,\n      attackCurve: \"linear\",\n      decay: 0.1,\n      decayCurve: \"exponential\",\n      release: 1,\n      releaseCurve: \"exponential\",\n      sustain: 0.5\n    });\n  }\n  /**\n   * Read the current value of the envelope. Useful for\n   * synchronizing visual output to the envelope.\n   */\n\n\n  get value() {\n    return this.getValueAtTime(this.now());\n  }\n  /**\n   * Get the curve\n   * @param  curve\n   * @param  direction  In/Out\n   * @return The curve name\n   */\n\n\n  _getCurve(curve, direction) {\n    if (isString(curve)) {\n      return curve;\n    } else {\n      // look up the name in the curves array\n      let curveName;\n\n      for (curveName in EnvelopeCurves) {\n        if (EnvelopeCurves[curveName][direction] === curve) {\n          return curveName;\n        }\n      } // return the custom curve\n\n\n      return curve;\n    }\n  }\n  /**\n   * Assign a the curve to the given name using the direction\n   * @param  name\n   * @param  direction In/Out\n   * @param  curve\n   */\n\n\n  _setCurve(name, direction, curve) {\n    // check if it's a valid type\n    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n      const curveDef = EnvelopeCurves[curve];\n\n      if (isObject(curveDef)) {\n        if (name !== \"_decayCurve\") {\n          this[name] = curveDef[direction];\n        }\n      } else {\n        this[name] = curveDef;\n      }\n    } else if (isArray(curve) && name !== \"_decayCurve\") {\n      this[name] = curve;\n    } else {\n      throw new Error(\"Envelope: invalid curve: \" + curve);\n    }\n  }\n  /**\n   * The shape of the attack.\n   * Can be any of these strings:\n   * * \"linear\"\n   * * \"exponential\"\n   * * \"sine\"\n   * * \"cosine\"\n   * * \"bounce\"\n   * * \"ripple\"\n   * * \"step\"\n   *\n   * Can also be an array which describes the curve. Values\n   * in the array are evenly subdivided and linearly\n   * interpolated over the duration of the attack.\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope(0.4).toDestination();\n   * \tenv.attackCurve = \"linear\";\n   * \tenv.triggerAttack();\n   * }, 1, 1);\n   */\n\n\n  get attackCurve() {\n    return this._getCurve(this._attackCurve, \"In\");\n  }\n\n  set attackCurve(curve) {\n    this._setCurve(\"_attackCurve\", \"In\", curve);\n  }\n  /**\n   * The shape of the release. See the attack curve types.\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope({\n   * \t\trelease: 0.8\n   * \t}).toDestination();\n   * \tenv.triggerAttack();\n   * \t// release curve could also be defined by an array\n   * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n   * \tenv.triggerRelease(0.2);\n   * }, 1, 1);\n   */\n\n\n  get releaseCurve() {\n    return this._getCurve(this._releaseCurve, \"Out\");\n  }\n\n  set releaseCurve(curve) {\n    this._setCurve(\"_releaseCurve\", \"Out\", curve);\n  }\n  /**\n   * The shape of the decay either \"linear\" or \"exponential\"\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope({\n   * \t\tsustain: 0.1,\n   * \t\tdecay: 0.5\n   * \t}).toDestination();\n   * \tenv.decayCurve = \"linear\";\n   * \tenv.triggerAttack();\n   * }, 1, 1);\n   */\n\n\n  get decayCurve() {\n    return this._decayCurve;\n  }\n\n  set decayCurve(curve) {\n    assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n    this._decayCurve = curve;\n  }\n  /**\n   * Trigger the attack/decay portion of the ADSR envelope.\n   * @param  time When the attack should start.\n   * @param velocity The velocity of the envelope scales the vales.\n   *                             number between 0-1\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n   * env.triggerAttack(\"+0.5\", 0.2);\n   */\n\n\n  triggerAttack(time) {\n    let velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.log(\"triggerAttack\", time, velocity);\n    time = this.toSeconds(time);\n    const originalAttack = this.toSeconds(this.attack);\n    let attack = originalAttack;\n    const decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      // subtract the current value from the attack time\n      const attackRate = 1 / attack;\n      const remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n      attack = remainingDistance / attackRate;\n    } // attack\n\n\n    if (attack < this.sampleTime) {\n      this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly\n\n\n      this._sig.setValueAtTime(velocity, time);\n    } else if (this._attackCurve === \"linear\") {\n      this._sig.linearRampTo(velocity, attack, time);\n    } else if (this._attackCurve === \"exponential\") {\n      this._sig.targetRampTo(velocity, attack, time);\n    } else {\n      this._sig.cancelAndHoldAtTime(time);\n\n      let curve = this._attackCurve; // find the starting position in the curve\n\n      for (let i = 1; i < curve.length; i++) {\n        // the starting index is between the two values\n        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n          curve = this._attackCurve.slice(i); // the first index is the current value\n\n          curve[0] = currentValue;\n          break;\n        }\n      }\n\n      this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n    } // decay\n\n\n    if (decay && this.sustain < 1) {\n      const decayValue = velocity * this.sustain;\n      const decayStart = time + attack;\n      this.log(\"decay\", decayStart);\n\n      if (this._decayCurve === \"linear\") {\n        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n      } else {\n        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Triggers the release of the envelope.\n   * @param  time When the release portion of the envelope should start.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator({\n   * \ttype: \"sawtooth\"\n   * }).connect(env).start();\n   * env.triggerAttack();\n   * // trigger the release half a second after the attack\n   * env.triggerRelease(\"+0.5\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    time = this.toSeconds(time);\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      const release = this.toSeconds(this.release);\n\n      if (release < this.sampleTime) {\n        this._sig.setValueAtTime(0, time);\n      } else if (this._releaseCurve === \"linear\") {\n        this._sig.linearRampTo(0, release, time);\n      } else if (this._releaseCurve === \"exponential\") {\n        this._sig.targetRampTo(0, release, time);\n      } else {\n        assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n        this._sig.cancelAndHoldAtTime(time);\n\n        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get the scheduled value at the given time. This will\n   * return the unconverted (raw) value.\n   * @example\n   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n   * env.triggerAttackRelease(2);\n   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n   */\n\n\n  getValueAtTime(time) {\n    return this._sig.getValueAtTime(time);\n  }\n  /**\n   * triggerAttackRelease is shorthand for triggerAttack, then waiting\n   * some duration, then triggerRelease.\n   * @param duration The duration of the sustain.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity of the envelope.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the release 0.5 seconds after the attack\n   * env.triggerAttackRelease(0.5);\n   */\n\n\n  triggerAttackRelease(duration, time) {\n    let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    time = this.toSeconds(time);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + this.toSeconds(duration));\n    return this;\n  }\n  /**\n   * Cancels all scheduled envelope changes after the given time.\n   */\n\n\n  cancel(after) {\n    this._sig.cancelScheduledValues(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * Connect the envelope to a destination node.\n   */\n\n\n  connect(destination) {\n    let outputNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let inputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    connectSignal(this, destination, outputNumber, inputNumber);\n    return this;\n  }\n  /**\n   * Render the envelope curve to an array of the given length.\n   * Good for visualizing the envelope curve. Rescales the duration of the\n   * envelope to fit the length.\n   */\n\n\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      const duration = length / this.context.sampleRate;\n      const context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n\n      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n      const envelopeDuration = attackPortion + this.toSeconds(this.release);\n      const sustainTime = envelopeDuration * 0.1;\n      const totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n\n      const clone = new this.constructor(Object.assign(this.get(), {\n        attack: duration * this.toSeconds(this.attack) / totalDuration,\n        decay: duration * this.toSeconds(this.decay) / totalDuration,\n        release: duration * this.toSeconds(this.release) / totalDuration,\n        context\n      }));\n\n      clone._sig.toDestination();\n\n      clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n      const buffer = yield context.render();\n      return buffer.getChannelData(0);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._sig.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\n\n\nconst EnvelopeCurves = (() => {\n  const curveLen = 128;\n  let i;\n  let k; // cosine curve\n\n  const cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  const rippleCurve = [];\n  const rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  const stairsCurve = [];\n  const steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  const sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  const bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    const freq = Math.pow(k, 3) * 4 + 0.2;\n    const val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    const out = new Array(curve.length);\n\n    for (let j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n})();","map":{"version":3,"mappings":"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","names":["ToneAudioNode","optionsFromArguments","isArray","isObject","isString","connectSignal","Signal","OfflineContext","assert","range","timeRange","Envelope","constructor","getDefaults","arguments","context","value","_sig","undefined","options","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","Object","assign","getValueAtTime","now","_getCurve","curve","direction","curveName","EnvelopeCurves","_setCurve","name","Reflect","has","curveDef","Error","_attackCurve","_releaseCurve","_decayCurve","some","c","triggerAttack","time","velocity","log","toSeconds","originalAttack","currentValue","attackRate","remainingDistance","sampleTime","cancelScheduledValues","setValueAtTime","linearRampTo","targetRampTo","cancelAndHoldAtTime","i","length","slice","setValueCurveAtTime","decayValue","decayStart","linearRampToValueAtTime","exponentialApproachValueAtTime","triggerRelease","triggerAttackRelease","duration","cancel","after","connect","destination","outputNumber","inputNumber","asArray","sampleRate","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","get","toDestination","buffer","render","getChannelData","dispose","__decorate","curveLen","k","cosineCurve","Math","sin","PI","rippleCurve","rippleCurveFreq","sineWave","stairsCurve","steps","ceil","sineCurve","cos","bounceCurve","freq","pow","val","abs","invertCurve","out","Array","j","reverseCurve","reverse","bounce","In","Out","cosine","exponential","linear","ripple","sine","step"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/component/envelope/Envelope.ts"],"sourcesContent":["import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\t@range(0, 1)\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope(0.4).toDestination();\n\t * \tenv.attackCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\trelease: 0.8\n\t * \t}).toDestination();\n\t * \tenv.triggerAttack();\n\t * \t// release curve could also be defined by an array\n\t * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n\t * \tenv.triggerRelease(0.2);\n\t * }, 1, 1);\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\tsustain: 0.1,\n\t * \t\tdecay: 0.5\n\t * \t}).toDestination();\n\t * \tenv.decayCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tassert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack < this.sampleTime) {\n\t\t\tthis._sig.cancelScheduledValues(time);\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay && this.sustain < 1) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n\t\t\t} else {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator({\n\t * \ttype: \"sawtooth\"\n\t * }).connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (release < this.sampleTime) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tassert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t * @example\n\t * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n\t * env.triggerAttackRelease(2);\n\t * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length. \n\t * Good for visualizing the envelope curve. Rescales the duration of the\n\t * envelope to fit the length.\n\t */\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(1, duration, this.context.sampleRate);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(Object.assign(this.get(), {\n\t\t\tattack: duration * this.toSeconds(this.attack) / totalDuration,\n\t\t\tdecay: duration * this.toSeconds(this.decay) / totalDuration,\n\t\t\trelease: duration * this.toSeconds(this.release) / totalDuration,\n\t\t\tcontext\n\t\t})) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n"]},"metadata":{},"sourceType":"module"}