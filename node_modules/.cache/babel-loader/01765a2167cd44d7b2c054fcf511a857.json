{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\n\nexport class Monophonic extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n    const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    this.portamento = options.portamento;\n    this.onsilence = options.onsilence;\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  }\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n\n\n  triggerAttack(note, time) {\n    let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    this.log(\"triggerAttack\", note, time, velocity);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeAttack(seconds, velocity);\n\n    this.setNote(note, seconds);\n    return this;\n  }\n  /**\n   * Trigger the release portion of the envelope\n   * @param  time If no time is given, the release happens immediatly\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeRelease(seconds);\n\n    return this;\n  }\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n\n\n  setNote(note, time) {\n    const computedTime = this.toSeconds(time);\n    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      const portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","map":{"version":3,"mappings":";AAAA,SAASA,cAAT,QAA+B,wBAA/B;AAEA,SAASC,oBAAT,QAAqC,uBAArC;AACA,SAASC,IAAT,QAAqB,wBAArB;AACA,SAASC,UAAT,QAA8C,0BAA9C;AAEA,SAASC,SAAT,QAA0B,wBAA1B;AAUA;;;;AAGA,OAAM,MAAgBC,UAAhB,SAAsEF,UAAtE,CAAyF;EAwB9FG;IAEC,MAAML,oBAAoB,CAACI,UAAU,CAACE,WAAX,EAAD,EAA2BC,SAA3B,CAA1B;IACA,MAAMC,OAAO,GAAGR,oBAAoB,CAACI,UAAU,CAACE,WAAX,EAAD,EAA2BC,SAA3B,CAApC;IAEA,KAAKE,UAAL,GAAkBD,OAAO,CAACC,UAA1B;IACA,KAAKC,SAAL,GAAiBF,OAAO,CAACE,SAAzB;EACA;;EAEiB,OAAXJ,WAAW;IACjB,OAAOK,MAAM,CAACC,MAAP,CAAcV,UAAU,CAACI,WAAX,EAAd,EAAwC;MAC9CO,MAAM,EAAE,CADsC;MAE9CH,SAAS,EAAET,IAFmC;MAG9CQ,UAAU,EAAE;IAHkC,CAAxC,CAAP;EAKA;EAED;;;;;;;;;;;;EAUAK,aAAa,CAACC,IAAD,EAAmCC,IAAnC,EAAyE;IAAA,IAAzBC,QAAyB,uEAAD,CAAC;IACrF,KAAKC,GAAL,CAAS,eAAT,EAA0BH,IAA1B,EAAgCC,IAAhC,EAAsCC,QAAtC;IACA,MAAME,OAAO,GAAG,KAAKC,SAAL,CAAeJ,IAAf,CAAhB;;IACA,KAAKK,sBAAL,CAA4BF,OAA5B,EAAqCF,QAArC;;IACA,KAAKK,OAAL,CAAaP,IAAb,EAAmBI,OAAnB;IACA,OAAO,IAAP;EACA;EAED;;;;;;;;;;;EASAI,cAAc,CAACP,IAAD,EAAY;IACzB,KAAKE,GAAL,CAAS,gBAAT,EAA2BF,IAA3B;IACA,MAAMG,OAAO,GAAG,KAAKC,SAAL,CAAeJ,IAAf,CAAhB;;IACA,KAAKQ,uBAAL,CAA6BL,OAA7B;;IACA,OAAO,IAAP;EACA;EAoBD;;;;;;;;;;;;;EAWAG,OAAO,CAACP,IAAD,EAAmCC,IAAnC,EAA8C;IACpD,MAAMS,YAAY,GAAG,KAAKL,SAAL,CAAeJ,IAAf,CAArB;IACA,MAAMU,iBAAiB,GAAGX,IAAI,YAAYhB,cAAhB,GAAiCgB,IAAI,CAACY,WAAL,EAAjC,GAAsDZ,IAAhF;;IACA,IAAI,KAAKN,UAAL,GAAkB,CAAlB,IAAuB,KAAKmB,cAAL,CAAoBH,YAApB,IAAoC,IAA/D,EAAqE;MACpE,MAAMI,QAAQ,GAAG,KAAKT,SAAL,CAAe,KAAKX,UAApB,CAAjB;MACA,KAAKqB,SAAL,CAAeC,iBAAf,CAAiCL,iBAAjC,EAAoDG,QAApD,EAA8DJ,YAA9D;IACA,CAHD,MAGO;MACN,KAAKK,SAAL,CAAeE,cAAf,CAA8BN,iBAA9B,EAAiDD,YAAjD;IACA;;IACD,OAAO,IAAP;EACA;;AAlH6F;;AAM9FQ,YADC9B,SAAS,CAAC,CAAD,CACV","names":["FrequencyClass","optionsFromArguments","noOp","Instrument","timeRange","Monophonic","constructor","getDefaults","arguments","options","portamento","onsilence","Object","assign","detune","triggerAttack","note","time","velocity","log","seconds","toSeconds","_triggerEnvelopeAttack","setNote","triggerRelease","_triggerEnvelopeRelease","computedTime","computedFrequency","toFrequency","getLevelAtTime","portTime","frequency","exponentialRampTo","setValueAtTime","__decorate"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/instrument/Monophonic.ts"],"sourcesContent":["import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\nimport { timeRange } from \"../core/util/Decorator\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}