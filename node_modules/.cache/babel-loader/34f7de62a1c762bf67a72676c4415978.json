{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nexport class Oscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    this._oscillator = null;\n    const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, \"detune\");\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      this._type = this.baseType + options.partialCount.toString();\n    }\n\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    const computedTime = this.toSeconds(time); // new oscillator with previous values\n\n    const oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: () => this.onstop(this)\n    });\n    this._oscillator = oscillator;\n\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    } // connect the control signal to the oscillator frequency & detune\n\n\n    this._oscillator.connect(this.output);\n\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune); // start the oscillator\n\n    this._oscillator.start(computedTime);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  }\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n\n\n  _restart(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n\n    this._state.cancel(computedTime);\n\n    return this;\n  }\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Tone.Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n\n\n  syncFrequency() {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n\n\n  unsyncFrequency() {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n\n\n  _getCachedPeriodicWave() {\n    if (this._type === \"custom\") {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.phase === this._phase && deepEquals(description.partials, this._partials);\n      });\n\n      return oscProps;\n    } else {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.type === this._type && description.phase === this._phase;\n      });\n\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n    const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n    if (this._phase === 0 && isBasicType) {\n      this._wave = undefined;\n      this._partialCount = 0; // just go with the basic approach\n\n      if (this._oscillator !== null) {\n        // already tested that it's a basic type\n        this._oscillator.type = type;\n      }\n    } else {\n      // first check if the value is cached\n      const cache = this._getCachedPeriodicWave();\n\n      if (isDefined(cache)) {\n        const {\n          partials,\n          wave\n        } = cache;\n        this._wave = wave;\n        this._partials = partials;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n      } else {\n        const [real, imag] = this._getRealImaginary(type, this._phase);\n\n        const periodicWave = this.context.createPeriodicWave(real, imag);\n        this._wave = periodicWave;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        } // set the cache\n\n\n        Oscillator._periodicWaveCache.push({\n          imag,\n          partialCount: this._partialCount,\n          partials: this._partials,\n          phase: this._phase,\n          real,\n          type: this._type,\n          wave: this._wave\n        });\n\n        if (Oscillator._periodicWaveCache.length > 100) {\n          Oscillator._periodicWaveCache.shift();\n        }\n      }\n    }\n  }\n\n  get baseType() {\n    return this._type.replace(this.partialCount.toString(), \"\");\n  }\n\n  set baseType(baseType) {\n    if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n      this.type = baseType + this.partialCount;\n    } else {\n      this.type = baseType;\n    }\n  }\n\n  get partialCount() {\n    return this._partialCount;\n  }\n\n  set partialCount(p) {\n    assertRange(p, 0);\n    let type = this._type;\n    const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n    if (partial) {\n      type = partial[1];\n    }\n\n    if (this._type !== \"custom\") {\n      if (p === 0) {\n        this.type = type;\n      } else {\n        this.type = type + p.toString();\n      }\n    } else {\n      // extend or shorten the partials array\n      const fullPartials = new Float32Array(p); // copy over the partials array\n\n      this._partials.forEach((v, i) => fullPartials[i] = v);\n\n      this._partials = Array.from(fullPartials);\n      this.type = this._type;\n    }\n  }\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n\n\n  _getRealImaginary(type, phase) {\n    const fftSize = 4096;\n    let periodicWaveSize = fftSize / 2;\n    const real = new Float32Array(periodicWaveSize);\n    const imag = new Float32Array(periodicWaveSize);\n    let partialCount = 1;\n\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n\n      this._partials = [];\n    }\n\n    for (let n = 1; n < periodicWaveSize; ++n) {\n      const piFactor = 2 / (n * Math.PI);\n      let b;\n\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n\n          this._partials[n - 1] = b;\n          break;\n\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n\n    return [real, imag];\n  }\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n\n\n  _inverseFFT(real, imag, phase) {\n    let sum = 0;\n    const len = real.length;\n\n    for (let i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n\n    return sum;\n  }\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n\n\n  getInitialValue() {\n    const [real, imag] = this._getRealImaginary(this._type, 0);\n\n    let maxValue = 0;\n    const twoPi = Math.PI * 2;\n    const testPositions = 32; // check for peaks in 16 places\n\n    for (let i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  }\n\n  get partials() {\n    return this._partials.slice(0, this.partialCount);\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this.type = \"custom\";\n    }\n  }\n\n  get phase() {\n    return this._phase * (180 / Math.PI);\n  }\n\n  set phase(phase) {\n    this._phase = phase * Math.PI / 180; // reset the type\n\n    this.type = this._type;\n  }\n\n  asArray() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\n\nOscillator._periodicWaveCache = [];","map":{"version":3,"mappings":"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","names":["deepEquals","optionsFromArguments","readOnly","isDefined","Signal","Source","generateWaveform","ToneOscillatorNode","assertRange","clamp","Oscillator","constructor","getDefaults","arguments","options","frequency","context","units","value","detune","_partials","partials","_partialCount","partialCount","_type","type","baseType","toString","phase","Object","assign","_start","time","computedTime","toSeconds","oscillator","onended","onstop","_oscillator","_wave","setPeriodicWave","connect","output","start","_stop","stop","_restart","log","cancelStop","_state","cancel","syncFrequency","transport","syncSignal","unsyncFrequency","unsyncSignal","_getCachedPeriodicWave","oscProps","_periodicWaveCache","find","description","_phase","isBasicType","indexOf","undefined","cache","wave","real","imag","_getRealImaginary","periodicWave","createPeriodicWave","push","length","shift","replace","p","partial","exec","fullPartials","Float32Array","forEach","v","i","Array","from","fftSize","periodicWaveSize","parseInt","Math","max","n","piFactor","PI","b","TypeError","sin","cos","_inverseFFT","sum","len","getInitialValue","maxValue","twoPi","testPositions","slice","asArray","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/source/oscillator/Oscillator.ts"],"sourcesContent":["import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport {\n\tgenerateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): { real: Float32Array; imag: Float32Array; partials: number[]; wave: PeriodicWave } | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}