{"ast":null,"code":"import { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\n\nexport class SyncedSignal extends Signal {\n  constructor() {\n    super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    this.name = \"SyncedSignal\";\n    /**\n     * Don't override when something is connected to the input\n     */\n\n    this.override = false;\n    const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    this._lastVal = options.value;\n    this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n    this._syncedCallback = this._anchorValue.bind(this);\n    this.context.transport.on(\"start\", this._syncedCallback);\n    this.context.transport.on(\"pause\", this._syncedCallback);\n    this.context.transport.on(\"stop\", this._syncedCallback); // disconnect the constant source from the output and replace it with another one\n\n    this._constantSource.disconnect();\n\n    this._constantSource.stop(0); // create a new one\n\n\n    this._constantSource = this.output = new ToneConstantSource({\n      context: this.context,\n      offset: options.value,\n      units: options.units\n    }).start(0);\n    this.setValueAtTime(options.value, 0);\n  }\n  /**\n   * Callback which is invoked every tick.\n   */\n\n\n  _onTick(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds); // approximate ramp curves with linear ramps\n\n    if (this._lastVal !== val) {\n      this._lastVal = val;\n\n      this._constantSource.offset.setValueAtTime(val, time);\n    }\n  }\n  /**\n   * Anchor the value at the start and stop of the Transport\n   */\n\n\n  _anchorValue(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds);\n    this._lastVal = val;\n\n    this._constantSource.offset.cancelAndHoldAtTime(time);\n\n    this._constantSource.offset.setValueAtTime(val, time);\n  }\n\n  getValueAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    return super.getValueAtTime(computedTime);\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setValueAtTime(value, computedTime);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.linearRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.exponentialRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.setTargetAtTime(value, computedTime, timeConstant);\n    return this;\n  }\n\n  cancelScheduledValues(startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.cancelScheduledValues(computedTime);\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    duration = this.toSeconds(duration);\n    super.setValueCurveAtTime(values, computedTime, duration, scaling);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.cancelAndHoldAtTime(computedTime);\n    return this;\n  }\n\n  setRampPoint(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setRampPoint(computedTime);\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.exponentialRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.linearRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.targetRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.context.transport.clear(this._synced);\n    this.context.transport.off(\"start\", this._syncedCallback);\n    this.context.transport.off(\"pause\", this._syncedCallback);\n    this.context.transport.off(\"stop\", this._syncedCallback);\n\n    this._constantSource.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Signal","optionsFromArguments","TransportTimeClass","ToneConstantSource","SyncedSignal","constructor","getDefaults","arguments","options","_lastVal","value","_synced","context","transport","scheduleRepeat","_onTick","bind","_syncedCallback","_anchorValue","on","_constantSource","disconnect","stop","output","offset","units","start","setValueAtTime","time","val","getValueAtTime","seconds","cancelAndHoldAtTime","computedTime","toSeconds","linearRampToValueAtTime","exponentialRampToValueAtTime","setTargetAtTime","startTime","timeConstant","cancelScheduledValues","setValueCurveAtTime","values","duration","scaling","setRampPoint","exponentialRampTo","rampTime","linearRampTo","targetRampTo","dispose","clear","off"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/signal/SyncedSignal.ts"],"sourcesContent":["import { Signal, SignalOptions } from \"./Signal\";\nimport { NormalRange, Seconds, Time, TransportTime, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\nimport { OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal<TypeName extends UnitName = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"SyncedSignal\";\n\t\n\t/**\n\t * Don't override when something is connected to the input\n\t */\n\treadonly override = false;\n\n\treadonly output: OutputNode;\n\n\t/**\n\t * Keep track of the last value as an optimization.\n\t */\n\tprivate _lastVal: UnitMap[TypeName];\n\n\t/**\n\t * The ID returned from scheduleRepeat\n\t */\n\tprivate _synced: number;\n\n\t/**\n\t * Remember the callback value\n\t */\n\tprivate _syncedCallback: () => void;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis._lastVal = options.value;\n\t\tthis._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n\n\t\tthis._syncedCallback = this._anchorValue.bind(this);\n\t\tthis.context.transport.on(\"start\", this._syncedCallback);\n\t\tthis.context.transport.on(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.on(\"stop\", this._syncedCallback);\n\n\t\t// disconnect the constant source from the output and replace it with another one\n\t\tthis._constantSource.disconnect();\n\t\tthis._constantSource.stop(0);\n\n\t\t// create a new one\n\t\tthis._constantSource = this.output = new ToneConstantSource<TypeName>({ \n\t\t\tcontext: this.context,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t}).start(0);\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\t/**\n\t * Callback which is invoked every tick.\n\t */\n\tprivate _onTick(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\t// approximate ramp curves with linear ramps\n\t\tif (this._lastVal !== val) {\n\t\t\tthis._lastVal = val;\n\t\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t\t}\n\t}\n\n\t/**\n\t * Anchor the value at the start and stop of the Transport\n\t */\n\tprivate _anchorValue(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\tthis._lastVal = val;\n\t\tthis._constantSource.offset.cancelAndHoldAtTime(time);\n\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t}\n\n\tgetValueAtTime(time: TransportTime): UnitMap[TypeName] {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\treturn super.getValueAtTime(computedTime);\n\t}\n\t\n\tsetValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.linearRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.exponentialRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value, startTime: TransportTime, timeConstant: number): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.setTargetAtTime(value, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(startTime: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.cancelScheduledValues(computedTime);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: TransportTime, duration: Time, scaling: NormalRange): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tduration = this.toSeconds(duration);\n\t\tsuper.setValueCurveAtTime(values, computedTime, duration, scaling);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.cancelAndHoldAtTime(computedTime);\n\t\treturn this;\n\t}\n\t\n\tsetRampPoint(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setRampPoint(computedTime);\n\t\treturn this;\n\t}\n\t\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.exponentialRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\t\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.linearRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.targetRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.transport.clear(this._synced);\n\t\tthis.context.transport.off(\"start\", this._syncedCallback);\n\t\tthis.context.transport.off(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.off(\"stop\", this._syncedCallback);\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}