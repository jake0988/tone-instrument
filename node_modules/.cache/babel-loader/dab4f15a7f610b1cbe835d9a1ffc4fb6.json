{"ast":null,"code":"import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\n\nexport class FrequencyShifter extends Effect {\n  constructor() {\n    super(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"FrequencyShifter\";\n    const options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency,\n      minValue: -this.context.sampleRate / 2,\n      maxValue: this.context.sampleRate / 2\n    });\n    this._sine = new ToneOscillatorNode({\n      context: this.context,\n      type: \"sine\"\n    });\n    this._cosine = new Oscillator({\n      context: this.context,\n      phase: -90,\n      type: \"sine\"\n    });\n    this._sineMultiply = new Multiply({\n      context: this.context\n    });\n    this._cosineMultiply = new Multiply({\n      context: this.context\n    });\n    this._negate = new Negate({\n      context: this.context\n    });\n    this._add = new Add({\n      context: this.context\n    });\n    this._phaseShifter = new PhaseShiftAllpass({\n      context: this.context\n    });\n    this.effectSend.connect(this._phaseShifter); // connect the carrier frequency signal to the two oscillators\n\n    this.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n    this._phaseShifter.offset90.connect(this._cosineMultiply);\n\n    this._cosine.connect(this._cosineMultiply.factor);\n\n    this._phaseShifter.connect(this._sineMultiply);\n\n    this._sine.connect(this._sineMultiply.factor);\n\n    this._sineMultiply.connect(this._negate);\n\n    this._cosineMultiply.connect(this._add);\n\n    this._negate.connect(this._add.addend);\n\n    this._add.connect(this.effectReturn); // start the oscillators at the same time\n\n\n    const now = this.immediate();\n\n    this._sine.start(now);\n\n    this._cosine.start(now);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      frequency: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n\n    this._add.dispose();\n\n    this._cosine.dispose();\n\n    this._cosineMultiply.dispose();\n\n    this._negate.dispose();\n\n    this._phaseShifter.dispose();\n\n    this._sine.dispose();\n\n    this._sineMultiply.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["PhaseShiftAllpass","optionsFromArguments","Effect","Add","Multiply","Negate","Signal","Oscillator","ToneOscillatorNode","FrequencyShifter","constructor","getDefaults","arguments","options","frequency","context","units","value","minValue","sampleRate","maxValue","_sine","type","_cosine","phase","_sineMultiply","_cosineMultiply","_negate","_add","_phaseShifter","effectSend","connect","fan","offset90","factor","addend","effectReturn","now","immediate","start","Object","assign","dispose"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/effect/FrequencyShifter.ts"],"sourcesContent":["import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { Frequency } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n\ninterface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90° phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tminValue: -this.context.sampleRate / 2,\n\t\t\tmaxValue: this.context.sampleRate / 2,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}