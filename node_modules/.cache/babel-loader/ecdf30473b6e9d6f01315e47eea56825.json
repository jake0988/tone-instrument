{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport class OfflineContext extends Context {\n  constructor() {\n    super({\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    this._currentTime = 0;\n    this.isOffline = true;\n    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  now() {\n    return this._currentTime;\n  }\n  /**\n   * Same as this.now()\n   */\n\n\n  get currentTime() {\n    return this._currentTime;\n  }\n  /**\n   * Render just the clock portion of the audio context.\n   */\n\n\n  _renderClock(asynchronous) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let index = 0;\n\n      while (this._duration - this._currentTime >= 0) {\n        // invoke all the callbacks on that time\n        this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n        this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n        index++;\n        const yieldEvery = Math.floor(this.sampleRate / 128);\n\n        if (asynchronous && index % yieldEvery === 0) {\n          yield new Promise(done => setTimeout(done, 1));\n        }\n      }\n    });\n  }\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n\n\n  render() {\n    let asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.workletsAreReady();\n      yield this._renderClock(asynchronous);\n      const buffer = yield this._context.startRendering();\n      return new ToneAudioBuffer(buffer);\n    });\n  }\n  /**\n   * Close the context\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n\n}","map":{"version":3,"mappings":";AAAA,SAASA,yBAAT,QAA0C,yBAA1C;AACA,SAASC,OAAT,QAAwB,oBAAxB;AAEA,SAASC,qBAAT,QAAsC,2BAAtC;AACA,SAASC,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;AAWA,OAAM,MAAOC,cAAP,SAA8BH,OAA9B,CAAqC;EAgC1CI;IAEC,MAAM;MACLC,WAAW,EAAE,SADR;MAELC,OAAO,EAAEL,qBAAqB,CAACM,SAAS,CAAC,CAAD,CAAV,CAArB,GACRA,SAAS,CAAC,CAAD,CADD,GACOR,yBAAyB,CAACQ,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAvC,EAA4CA,SAAS,CAAC,CAAD,CAArD,CAHpC;MAILC,SAAS,EAAE,CAJN;MAKLC,cAAc,EAAER,qBAAqB,CAACM,SAAS,CAAC,CAAD,CAAV,CAArB,GACf,MAAMA,SAAS,CAAC,CAAD,CAAT,CAAaG,UADJ,GACiB,MAAMH,SAAS,CAAC,CAAD;IAN3C,CAAN;IAhCQ,YAAe,gBAAf;IAOT;;;;IAGQ,oBAAwB,CAAxB;IAOC,iBAAqB,IAArB;IAwBR,KAAKI,SAAL,GAAiBV,qBAAqB,CAACM,SAAS,CAAC,CAAD,CAAV,CAArB,GAChBA,SAAS,CAAC,CAAD,CAAT,CAAaK,MAAb,GAAsBL,SAAS,CAAC,CAAD,CAAT,CAAaG,UADnB,GACgCH,SAAS,CAAC,CAAD,CAD1D;EAEA;EAED;;;;;EAGAM,GAAG;IACF,OAAO,KAAKC,YAAZ;EACA;EAED;;;;;EAGe,IAAXC,WAAW;IACd,OAAO,KAAKD,YAAZ;EACA;EAED;;;;;EAGcE,YAAY,CAACC,YAAD,EAAsB;;MAC/C,IAAIC,KAAK,GAAG,CAAZ;;MACA,OAAO,KAAKP,SAAL,GAAiB,KAAKG,YAAtB,IAAsC,CAA7C,EAAgD;QAE/C;QACA,KAAKK,IAAL,CAAU,MAAV,EAH+C,CAK/C;;QACA,KAAKL,YAAL,IAAqB,MAAM,KAAKJ,UAAhC,CAN+C,CAQ/C;;QACAQ,KAAK;QACL,MAAME,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAW,KAAKZ,UAAL,GAAkB,GAA7B,CAAnB;;QACA,IAAIO,YAAY,IAAIC,KAAK,GAAGE,UAAR,KAAuB,CAA3C,EAA8C;UAC7C,MAAM,IAAIG,OAAJ,CAAYC,IAAI,IAAIC,UAAU,CAACD,IAAD,EAAO,CAAP,CAA9B,CAAN;QACA;MACD;IACD;EAAA;EAED;;;;;;EAIME,MAAM,GAAoB;IAAA,IAAnBT,YAAmB,uEAAJ,IAAI;;MAC/B,MAAM,KAAKU,gBAAL,EAAN;MACA,MAAM,KAAKX,YAAL,CAAkBC,YAAlB,CAAN;MACA,MAAMW,MAAM,GAAG,MAAM,KAAKC,QAAL,CAAcC,cAAd,EAArB;MACA,OAAO,IAAI5B,eAAJ,CAAoB0B,MAApB,CAAP;IACA;EAAA;EAED;;;;;EAGAG,KAAK;IACJ,OAAOR,OAAO,CAACS,OAAR,EAAP;EACA;;AAnGyC","names":["createOfflineAudioContext","Context","isOfflineAudioContext","ToneAudioBuffer","OfflineContext","constructor","clockSource","context","arguments","lookAhead","updateInterval","sampleRate","_duration","length","now","_currentTime","currentTime","_renderClock","asynchronous","index","emit","yieldEvery","Math","floor","Promise","done","setTimeout","render","workletsAreReady","buffer","_context","startRendering","close","resolve"],"sources":["/Users/jakeg/code/tone-instrument/node_modules/tone/Tone/core/context/OfflineContext.ts"],"sourcesContent":["import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, \n\t\tsampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}